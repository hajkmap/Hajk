{"version":3,"file":"static/js/4185.ec17f4fd.chunk.js","mappings":"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","sources":["../node_modules/@turf/clone/dist/es/index.js","../node_modules/@turf/rhumb-destination/dist/es/index.js","../node_modules/@turf/transform-translate/dist/es/index.js","../node_modules/ol/Overlay.js"],"sourcesContent":["/**\n * Returns a cloned copy of the passed GeoJSON Object, including possible 'Foreign Members'.\n * ~3-5x faster than the common JSON.parse + JSON.stringify combo method.\n *\n * @name clone\n * @param {GeoJSON} geojson GeoJSON Object\n * @returns {GeoJSON} cloned GeoJSON Object\n * @example\n * var line = turf.lineString([[-74, 40], [-78, 42], [-82, 35]], {color: 'red'});\n *\n * var lineCloned = turf.clone(line);\n */\nfunction clone(geojson) {\n    if (!geojson) {\n        throw new Error(\"geojson is required\");\n    }\n    switch (geojson.type) {\n        case \"Feature\":\n            return cloneFeature(geojson);\n        case \"FeatureCollection\":\n            return cloneFeatureCollection(geojson);\n        case \"Point\":\n        case \"LineString\":\n        case \"Polygon\":\n        case \"MultiPoint\":\n        case \"MultiLineString\":\n        case \"MultiPolygon\":\n        case \"GeometryCollection\":\n            return cloneGeometry(geojson);\n        default:\n            throw new Error(\"unknown GeoJSON type\");\n    }\n}\n/**\n * Clone Feature\n *\n * @private\n * @param {Feature<any>} geojson GeoJSON Feature\n * @returns {Feature<any>} cloned Feature\n */\nfunction cloneFeature(geojson) {\n    var cloned = { type: \"Feature\" };\n    // Preserve Foreign Members\n    Object.keys(geojson).forEach(function (key) {\n        switch (key) {\n            case \"type\":\n            case \"properties\":\n            case \"geometry\":\n                return;\n            default:\n                cloned[key] = geojson[key];\n        }\n    });\n    // Add properties & geometry last\n    cloned.properties = cloneProperties(geojson.properties);\n    cloned.geometry = cloneGeometry(geojson.geometry);\n    return cloned;\n}\n/**\n * Clone Properties\n *\n * @private\n * @param {Object} properties GeoJSON Properties\n * @returns {Object} cloned Properties\n */\nfunction cloneProperties(properties) {\n    var cloned = {};\n    if (!properties) {\n        return cloned;\n    }\n    Object.keys(properties).forEach(function (key) {\n        var value = properties[key];\n        if (typeof value === \"object\") {\n            if (value === null) {\n                // handle null\n                cloned[key] = null;\n            }\n            else if (Array.isArray(value)) {\n                // handle Array\n                cloned[key] = value.map(function (item) {\n                    return item;\n                });\n            }\n            else {\n                // handle generic Object\n                cloned[key] = cloneProperties(value);\n            }\n        }\n        else {\n            cloned[key] = value;\n        }\n    });\n    return cloned;\n}\n/**\n * Clone Feature Collection\n *\n * @private\n * @param {FeatureCollection<any>} geojson GeoJSON Feature Collection\n * @returns {FeatureCollection<any>} cloned Feature Collection\n */\nfunction cloneFeatureCollection(geojson) {\n    var cloned = { type: \"FeatureCollection\" };\n    // Preserve Foreign Members\n    Object.keys(geojson).forEach(function (key) {\n        switch (key) {\n            case \"type\":\n            case \"features\":\n                return;\n            default:\n                cloned[key] = geojson[key];\n        }\n    });\n    // Add features\n    cloned.features = geojson.features.map(function (feature) {\n        return cloneFeature(feature);\n    });\n    return cloned;\n}\n/**\n * Clone Geometry\n *\n * @private\n * @param {Geometry<any>} geometry GeoJSON Geometry\n * @returns {Geometry<any>} cloned Geometry\n */\nfunction cloneGeometry(geometry) {\n    var geom = { type: geometry.type };\n    if (geometry.bbox) {\n        geom.bbox = geometry.bbox;\n    }\n    if (geometry.type === \"GeometryCollection\") {\n        geom.geometries = geometry.geometries.map(function (g) {\n            return cloneGeometry(g);\n        });\n        return geom;\n    }\n    geom.coordinates = deepSlice(geometry.coordinates);\n    return geom;\n}\n/**\n * Deep Slice coordinates\n *\n * @private\n * @param {Coordinates} coords Coordinates\n * @returns {Coordinates} all coordinates sliced\n */\nfunction deepSlice(coords) {\n    var cloned = coords;\n    if (typeof cloned[0] !== \"object\") {\n        return cloned.slice();\n    }\n    return cloned.map(function (coord) {\n        return deepSlice(coord);\n    });\n}\nexport default clone;\n","// https://en.wikipedia.org/wiki/Rhumb_line\nimport { convertLength, degreesToRadians, earthRadius, point, } from \"@turf/helpers\";\nimport { getCoord } from \"@turf/invariant\";\n/**\n * Returns the destination {@link Point} having travelled the given distance along a Rhumb line from the\n * origin Point with the (varant) given bearing.\n *\n * @name rhumbDestination\n * @param {Coord} origin starting point\n * @param {number} distance distance from the starting point\n * @param {number} bearing varant bearing angle ranging from -180 to 180 degrees from north\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] can be degrees, radians, miles, or kilometers\n * @param {Object} [options.properties={}] translate properties to destination point\n * @returns {Feature<Point>} Destination point.\n * @example\n * var pt = turf.point([-75.343, 39.984], {\"marker-color\": \"F00\"});\n * var distance = 50;\n * var bearing = 90;\n * var options = {units: 'miles'};\n *\n * var destination = turf.rhumbDestination(pt, distance, bearing, options);\n *\n * //addToMap\n * var addToMap = [pt, destination]\n * destination.properties['marker-color'] = '#00F';\n */\nfunction rhumbDestination(origin, distance, bearing, options) {\n    if (options === void 0) { options = {}; }\n    var wasNegativeDistance = distance < 0;\n    var distanceInMeters = convertLength(Math.abs(distance), options.units, \"meters\");\n    if (wasNegativeDistance)\n        distanceInMeters = -Math.abs(distanceInMeters);\n    var coords = getCoord(origin);\n    var destination = calculateRhumbDestination(coords, distanceInMeters, bearing);\n    // compensate the crossing of the 180th meridian (https://macwright.org/2016/09/26/the-180th-meridian.html)\n    // solution from https://github.com/mapbox/mapbox-gl-js/issues/3250#issuecomment-294887678\n    destination[0] +=\n        destination[0] - coords[0] > 180\n            ? -360\n            : coords[0] - destination[0] > 180\n                ? 360\n                : 0;\n    return point(destination, options.properties);\n}\n/**\n * Returns the destination point having travelled along a rhumb line from origin point the given\n * distance on the  given bearing.\n * Adapted from Geodesy: http://www.movable-type.co.uk/scripts/latlong.html#rhumblines\n *\n * @private\n * @param   {Array<number>} origin - point\n * @param   {number} distance - Distance travelled, in same units as earth radius (default: metres).\n * @param   {number} bearing - Bearing in degrees from north.\n * @param   {number} [radius=6371e3] - (Mean) radius of earth (defaults to radius in metres).\n * @returns {Array<number>} Destination point.\n */\nfunction calculateRhumbDestination(origin, distance, bearing, radius) {\n    // Ï† => phi\n    // Î» => lambda\n    // Ïˆ => psi\n    // Î” => Delta\n    // Î´ => delta\n    // Î¸ => theta\n    radius = radius === undefined ? earthRadius : Number(radius);\n    var delta = distance / radius; // angular distance in radians\n    var lambda1 = (origin[0] * Math.PI) / 180; // to radians, but without normalize to ðœ‹\n    var phi1 = degreesToRadians(origin[1]);\n    var theta = degreesToRadians(bearing);\n    var DeltaPhi = delta * Math.cos(theta);\n    var phi2 = phi1 + DeltaPhi;\n    // check for some daft bugger going past the pole, normalise latitude if so\n    if (Math.abs(phi2) > Math.PI / 2) {\n        phi2 = phi2 > 0 ? Math.PI - phi2 : -Math.PI - phi2;\n    }\n    var DeltaPsi = Math.log(Math.tan(phi2 / 2 + Math.PI / 4) / Math.tan(phi1 / 2 + Math.PI / 4));\n    // E-W course becomes ill-conditioned with 0/0\n    var q = Math.abs(DeltaPsi) > 10e-12 ? DeltaPhi / DeltaPsi : Math.cos(phi1);\n    var DeltaLambda = (delta * Math.sin(theta)) / q;\n    var lambda2 = lambda1 + DeltaLambda;\n    return [\n        (((lambda2 * 180) / Math.PI + 540) % 360) - 180,\n        (phi2 * 180) / Math.PI,\n    ]; // normalise to âˆ’180..+180Â°\n}\nexport default rhumbDestination;\n","import { coordEach } from '@turf/meta';\nimport { isObject } from '@turf/helpers';\nimport { getCoords } from '@turf/invariant';\nimport clone from '@turf/clone';\nimport rhumbDestination from '@turf/rhumb-destination';\n\n/**\n * Moves any geojson Feature or Geometry of a specified distance along a Rhumb Line\n * on the provided direction angle.\n *\n * @name transformTranslate\n * @param {GeoJSON} geojson object to be translated\n * @param {number} distance length of the motion; negative values determine motion in opposite direction\n * @param {number} direction of the motion; angle from North in decimal degrees, positive clockwise\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] in which `distance` will be express; miles, kilometers, degrees, or radians\n * @param {number} [options.zTranslation=0] length of the vertical motion, same unit of distance\n * @param {boolean} [options.mutate=false] allows GeoJSON input to be mutated (significant performance increase if true)\n * @returns {GeoJSON} the translated GeoJSON object\n * @example\n * var poly = turf.polygon([[[0,29],[3.5,29],[2.5,32],[0,29]]]);\n * var translatedPoly = turf.transformTranslate(poly, 100, 35);\n *\n * //addToMap\n * var addToMap = [poly, translatedPoly];\n * translatedPoly.properties = {stroke: '#F00', 'stroke-width': 4};\n */\nfunction transformTranslate(geojson, distance, direction, options) {\n  // Optional parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var units = options.units;\n  var zTranslation = options.zTranslation;\n  var mutate = options.mutate;\n\n  // Input validation\n  if (!geojson) throw new Error(\"geojson is required\");\n  if (distance === undefined || distance === null || isNaN(distance))\n    throw new Error(\"distance is required\");\n  if (zTranslation && typeof zTranslation !== \"number\" && isNaN(zTranslation))\n    throw new Error(\"zTranslation is not a number\");\n\n  // Shortcut no-motion\n  zTranslation = zTranslation !== undefined ? zTranslation : 0;\n  if (distance === 0 && zTranslation === 0) return geojson;\n\n  if (direction === undefined || direction === null || isNaN(direction))\n    throw new Error(\"direction is required\");\n\n  // Invert with negative distances\n  if (distance < 0) {\n    distance = -distance;\n    direction = direction + 180;\n  }\n\n  // Clone geojson to avoid side effects\n  if (mutate === false || mutate === undefined) geojson = clone(geojson);\n\n  // Translate each coordinate\n  coordEach(geojson, function (pointCoords) {\n    var newCoords = getCoords(\n      rhumbDestination(pointCoords, distance, direction, { units: units })\n    );\n    pointCoords[0] = newCoords[0];\n    pointCoords[1] = newCoords[1];\n    if (zTranslation && pointCoords.length === 3)\n      pointCoords[2] += zTranslation;\n  });\n  return geojson;\n}\n\nexport default transformTranslate;\n","/**\n * @module ol/Overlay\n */\nimport BaseObject from './Object.js';\nimport MapEventType from './MapEventType.js';\nimport {CLASS_SELECTABLE} from './css.js';\nimport {containsExtent} from './extent.js';\nimport {listen, unlistenByKey} from './events.js';\nimport {outerHeight, outerWidth, removeChildren, removeNode} from './dom.js';\n\n/**\n * @typedef {'bottom-left' | 'bottom-center' | 'bottom-right' | 'center-left' | 'center-center' | 'center-right' | 'top-left' | 'top-center' | 'top-right'} Positioning\n * The overlay position: `'bottom-left'`, `'bottom-center'`,  `'bottom-right'`,\n * `'center-left'`, `'center-center'`, `'center-right'`, `'top-left'`,\n * `'top-center'`, or `'top-right'`.\n */\n\n/**\n * @typedef {Object} Options\n * @property {number|string} [id] Set the overlay id. The overlay id can be used\n * with the {@link module:ol/Map~Map#getOverlayById} method.\n * @property {HTMLElement} [element] The overlay element.\n * @property {Array<number>} [offset=[0, 0]] Offsets in pixels used when positioning\n * the overlay. The first element in the\n * array is the horizontal offset. A positive value shifts the overlay right.\n * The second element in the array is the vertical offset. A positive value\n * shifts the overlay down.\n * @property {import(\"./coordinate.js\").Coordinate} [position] The overlay position\n * in map projection.\n * @property {Positioning} [positioning='top-left'] Defines how\n * the overlay is actually positioned with respect to its `position` property.\n * Possible values are `'bottom-left'`, `'bottom-center'`, `'bottom-right'`,\n * `'center-left'`, `'center-center'`, `'center-right'`, `'top-left'`,\n * `'top-center'`, and `'top-right'`.\n * @property {boolean} [stopEvent=true] Whether event propagation to the map\n * viewport should be stopped. If `true` the overlay is placed in the same\n * container as that of the controls (CSS class name\n * `ol-overlaycontainer-stopevent`); if `false` it is placed in the container\n * with CSS class name specified by the `className` property.\n * @property {boolean} [insertFirst=true] Whether the overlay is inserted first\n * in the overlay container, or appended. If the overlay is placed in the same\n * container as that of the controls (see the `stopEvent` option) you will\n * probably set `insertFirst` to `true` so the overlay is displayed below the\n * controls.\n * @property {PanIntoViewOptions|boolean} [autoPan=false] Pan the map when calling\n * `setPosition`, so that the overlay is entirely visible in the current viewport.\n * @property {string} [className='ol-overlay-container ol-selectable'] CSS class\n * name.\n */\n\n/**\n * @typedef {Object} PanOptions\n * @property {number} [duration=1000] The duration of the animation in\n * milliseconds.\n * @property {function(number):number} [easing] The easing function to use. Can\n * be one from {@link module:ol/easing} or a custom function.\n * Default is {@link module:ol/easing.inAndOut}.\n */\n\n/**\n * @typedef {Object} PanIntoViewOptions\n * @property {PanOptions} [animation={}] The animation parameters for the pan\n * @property {number} [margin=20] The margin (in pixels) between the\n * overlay and the borders of the map when panning into view.\n */\n\n/**\n * @enum {string}\n * @protected\n */\nconst Property = {\n  ELEMENT: 'element',\n  MAP: 'map',\n  OFFSET: 'offset',\n  POSITION: 'position',\n  POSITIONING: 'positioning',\n};\n\n/**\n * @typedef {import(\"./ObjectEventType\").Types|'change:element'|'change:map'|'change:offset'|'change:position'|\n *   'change:positioning'} OverlayObjectEventTypes\n */\n\n/***\n * @template Return\n * @typedef {import(\"./Observable\").OnSignature<import(\"./Observable\").EventTypes, import(\"./events/Event.js\").default, Return> &\n *   import(\"./Observable\").OnSignature<OverlayObjectEventTypes, import(\"./Object\").ObjectEvent, Return> &\n *   import(\"./Observable\").CombinedOnSignature<import(\"./Observable\").EventTypes|OverlayObjectEventTypes, Return>} OverlayOnSignature\n */\n\n/**\n * @classdesc\n * An element to be displayed over the map and attached to a single map\n * location.  Like {@link module:ol/control/Control~Control}, Overlays are\n * visible widgets. Unlike Controls, they are not in a fixed position on the\n * screen, but are tied to a geographical coordinate, so panning the map will\n * move an Overlay but not a Control.\n *\n * Example:\n *\n *     import Overlay from 'ol/Overlay';\n *\n *     // ...\n *     const popup = new Overlay({\n *       element: document.getElementById('popup'),\n *     });\n *     popup.setPosition(coordinate);\n *     map.addOverlay(popup);\n *\n * @api\n */\nclass Overlay extends BaseObject {\n  /**\n   * @param {Options} options Overlay options.\n   */\n  constructor(options) {\n    super();\n\n    /***\n     * @type {OverlayOnSignature<import(\"./events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {OverlayOnSignature<import(\"./events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {OverlayOnSignature<void>}\n     */\n    this.un;\n\n    /**\n     * @protected\n     * @type {Options}\n     */\n    this.options = options;\n\n    /**\n     * @protected\n     * @type {number|string|undefined}\n     */\n    this.id = options.id;\n\n    /**\n     * @protected\n     * @type {boolean}\n     */\n    this.insertFirst =\n      options.insertFirst !== undefined ? options.insertFirst : true;\n\n    /**\n     * @protected\n     * @type {boolean}\n     */\n    this.stopEvent = options.stopEvent !== undefined ? options.stopEvent : true;\n\n    /**\n     * @protected\n     * @type {HTMLElement}\n     */\n    this.element = document.createElement('div');\n    this.element.className =\n      options.className !== undefined\n        ? options.className\n        : 'ol-overlay-container ' + CLASS_SELECTABLE;\n    this.element.style.position = 'absolute';\n    this.element.style.pointerEvents = 'auto';\n\n    /**\n     * @protected\n     * @type {PanIntoViewOptions|undefined}\n     */\n    this.autoPan = options.autoPan === true ? {} : options.autoPan || undefined;\n\n    /**\n     * @protected\n     * @type {{transform_: string,\n     *         visible: boolean}}\n     */\n    this.rendered = {\n      transform_: '',\n      visible: true,\n    };\n\n    /**\n     * @protected\n     * @type {?import(\"./events.js\").EventsKey}\n     */\n    this.mapPostrenderListenerKey = null;\n\n    this.addChangeListener(Property.ELEMENT, this.handleElementChanged);\n    this.addChangeListener(Property.MAP, this.handleMapChanged);\n    this.addChangeListener(Property.OFFSET, this.handleOffsetChanged);\n    this.addChangeListener(Property.POSITION, this.handlePositionChanged);\n    this.addChangeListener(Property.POSITIONING, this.handlePositioningChanged);\n\n    if (options.element !== undefined) {\n      this.setElement(options.element);\n    }\n\n    this.setOffset(options.offset !== undefined ? options.offset : [0, 0]);\n\n    this.setPositioning(options.positioning || 'top-left');\n\n    if (options.position !== undefined) {\n      this.setPosition(options.position);\n    }\n  }\n\n  /**\n   * Get the DOM element of this overlay.\n   * @return {HTMLElement|undefined} The Element containing the overlay.\n   * @observable\n   * @api\n   */\n  getElement() {\n    return /** @type {HTMLElement|undefined} */ (this.get(Property.ELEMENT));\n  }\n\n  /**\n   * Get the overlay identifier which is set on constructor.\n   * @return {number|string|undefined} Id.\n   * @api\n   */\n  getId() {\n    return this.id;\n  }\n\n  /**\n   * Get the map associated with this overlay.\n   * @return {import(\"./Map.js\").default|null} The map that the\n   * overlay is part of.\n   * @observable\n   * @api\n   */\n  getMap() {\n    return /** @type {import(\"./Map.js\").default|null} */ (\n      this.get(Property.MAP) || null\n    );\n  }\n\n  /**\n   * Get the offset of this overlay.\n   * @return {Array<number>} The offset.\n   * @observable\n   * @api\n   */\n  getOffset() {\n    return /** @type {Array<number>} */ (this.get(Property.OFFSET));\n  }\n\n  /**\n   * Get the current position of this overlay.\n   * @return {import(\"./coordinate.js\").Coordinate|undefined} The spatial point that the overlay is\n   *     anchored at.\n   * @observable\n   * @api\n   */\n  getPosition() {\n    return /** @type {import(\"./coordinate.js\").Coordinate|undefined} */ (\n      this.get(Property.POSITION)\n    );\n  }\n\n  /**\n   * Get the current positioning of this overlay.\n   * @return {Positioning} How the overlay is positioned\n   *     relative to its point on the map.\n   * @observable\n   * @api\n   */\n  getPositioning() {\n    return /** @type {Positioning} */ (this.get(Property.POSITIONING));\n  }\n\n  /**\n   * @protected\n   */\n  handleElementChanged() {\n    removeChildren(this.element);\n    const element = this.getElement();\n    if (element) {\n      this.element.appendChild(element);\n    }\n  }\n\n  /**\n   * @protected\n   */\n  handleMapChanged() {\n    if (this.mapPostrenderListenerKey) {\n      removeNode(this.element);\n      unlistenByKey(this.mapPostrenderListenerKey);\n      this.mapPostrenderListenerKey = null;\n    }\n    const map = this.getMap();\n    if (map) {\n      this.mapPostrenderListenerKey = listen(\n        map,\n        MapEventType.POSTRENDER,\n        this.render,\n        this\n      );\n      this.updatePixelPosition();\n      const container = this.stopEvent\n        ? map.getOverlayContainerStopEvent()\n        : map.getOverlayContainer();\n      if (this.insertFirst) {\n        container.insertBefore(this.element, container.childNodes[0] || null);\n      } else {\n        container.appendChild(this.element);\n      }\n      this.performAutoPan();\n    }\n  }\n\n  /**\n   * @protected\n   */\n  render() {\n    this.updatePixelPosition();\n  }\n\n  /**\n   * @protected\n   */\n  handleOffsetChanged() {\n    this.updatePixelPosition();\n  }\n\n  /**\n   * @protected\n   */\n  handlePositionChanged() {\n    this.updatePixelPosition();\n    this.performAutoPan();\n  }\n\n  /**\n   * @protected\n   */\n  handlePositioningChanged() {\n    this.updatePixelPosition();\n  }\n\n  /**\n   * Set the DOM element to be associated with this overlay.\n   * @param {HTMLElement|undefined} element The Element containing the overlay.\n   * @observable\n   * @api\n   */\n  setElement(element) {\n    this.set(Property.ELEMENT, element);\n  }\n\n  /**\n   * Set the map to be associated with this overlay.\n   * @param {import(\"./Map.js\").default|null} map The map that the\n   * overlay is part of. Pass `null` to just remove the overlay from the current map.\n   * @observable\n   * @api\n   */\n  setMap(map) {\n    this.set(Property.MAP, map);\n  }\n\n  /**\n   * Set the offset for this overlay.\n   * @param {Array<number>} offset Offset.\n   * @observable\n   * @api\n   */\n  setOffset(offset) {\n    this.set(Property.OFFSET, offset);\n  }\n\n  /**\n   * Set the position for this overlay. If the position is `undefined` the\n   * overlay is hidden.\n   * @param {import(\"./coordinate.js\").Coordinate|undefined} position The spatial point that the overlay\n   *     is anchored at.\n   * @observable\n   * @api\n   */\n  setPosition(position) {\n    this.set(Property.POSITION, position);\n  }\n\n  /**\n   * Pan the map so that the overlay is entirely visible in the current viewport\n   * (if necessary) using the configured autoPan parameters\n   * @protected\n   */\n  performAutoPan() {\n    if (this.autoPan) {\n      this.panIntoView(this.autoPan);\n    }\n  }\n\n  /**\n   * Pan the map so that the overlay is entirely visible in the current viewport\n   * (if necessary).\n   * @param {PanIntoViewOptions} [panIntoViewOptions] Options for the pan action\n   * @api\n   */\n  panIntoView(panIntoViewOptions) {\n    const map = this.getMap();\n\n    if (!map || !map.getTargetElement() || !this.get(Property.POSITION)) {\n      return;\n    }\n\n    const mapRect = this.getRect(map.getTargetElement(), map.getSize());\n    const element = this.getElement();\n    const overlayRect = this.getRect(element, [\n      outerWidth(element),\n      outerHeight(element),\n    ]);\n\n    panIntoViewOptions = panIntoViewOptions || {};\n\n    const myMargin =\n      panIntoViewOptions.margin === undefined ? 20 : panIntoViewOptions.margin;\n    if (!containsExtent(mapRect, overlayRect)) {\n      // the overlay is not completely inside the viewport, so pan the map\n      const offsetLeft = overlayRect[0] - mapRect[0];\n      const offsetRight = mapRect[2] - overlayRect[2];\n      const offsetTop = overlayRect[1] - mapRect[1];\n      const offsetBottom = mapRect[3] - overlayRect[3];\n\n      const delta = [0, 0];\n      if (offsetLeft < 0) {\n        // move map to the left\n        delta[0] = offsetLeft - myMargin;\n      } else if (offsetRight < 0) {\n        // move map to the right\n        delta[0] = Math.abs(offsetRight) + myMargin;\n      }\n      if (offsetTop < 0) {\n        // move map up\n        delta[1] = offsetTop - myMargin;\n      } else if (offsetBottom < 0) {\n        // move map down\n        delta[1] = Math.abs(offsetBottom) + myMargin;\n      }\n\n      if (delta[0] !== 0 || delta[1] !== 0) {\n        const center = /** @type {import(\"./coordinate.js\").Coordinate} */ (\n          map.getView().getCenterInternal()\n        );\n        const centerPx = map.getPixelFromCoordinateInternal(center);\n        if (!centerPx) {\n          return;\n        }\n        const newCenterPx = [centerPx[0] + delta[0], centerPx[1] + delta[1]];\n\n        const panOptions = panIntoViewOptions.animation || {};\n        map.getView().animateInternal({\n          center: map.getCoordinateFromPixelInternal(newCenterPx),\n          duration: panOptions.duration,\n          easing: panOptions.easing,\n        });\n      }\n    }\n  }\n\n  /**\n   * Get the extent of an element relative to the document\n   * @param {HTMLElement} element The element.\n   * @param {import(\"./size.js\").Size} size The size of the element.\n   * @return {import(\"./extent.js\").Extent} The extent.\n   * @protected\n   */\n  getRect(element, size) {\n    const box = element.getBoundingClientRect();\n    const offsetX = box.left + window.pageXOffset;\n    const offsetY = box.top + window.pageYOffset;\n    return [offsetX, offsetY, offsetX + size[0], offsetY + size[1]];\n  }\n\n  /**\n   * Set the positioning for this overlay.\n   * @param {Positioning} positioning how the overlay is\n   *     positioned relative to its point on the map.\n   * @observable\n   * @api\n   */\n  setPositioning(positioning) {\n    this.set(Property.POSITIONING, positioning);\n  }\n\n  /**\n   * Modify the visibility of the element.\n   * @param {boolean} visible Element visibility.\n   * @protected\n   */\n  setVisible(visible) {\n    if (this.rendered.visible !== visible) {\n      this.element.style.display = visible ? '' : 'none';\n      this.rendered.visible = visible;\n    }\n  }\n\n  /**\n   * Update pixel position.\n   * @protected\n   */\n  updatePixelPosition() {\n    const map = this.getMap();\n    const position = this.getPosition();\n    if (!map || !map.isRendered() || !position) {\n      this.setVisible(false);\n      return;\n    }\n\n    const pixel = map.getPixelFromCoordinate(position);\n    const mapSize = map.getSize();\n    this.updateRenderedPosition(pixel, mapSize);\n  }\n\n  /**\n   * @param {import(\"./pixel.js\").Pixel} pixel The pixel location.\n   * @param {import(\"./size.js\").Size|undefined} mapSize The map size.\n   * @protected\n   */\n  updateRenderedPosition(pixel, mapSize) {\n    const style = this.element.style;\n    const offset = this.getOffset();\n\n    const positioning = this.getPositioning();\n\n    this.setVisible(true);\n\n    const x = Math.round(pixel[0] + offset[0]) + 'px';\n    const y = Math.round(pixel[1] + offset[1]) + 'px';\n    let posX = '0%';\n    let posY = '0%';\n    if (\n      positioning == 'bottom-right' ||\n      positioning == 'center-right' ||\n      positioning == 'top-right'\n    ) {\n      posX = '-100%';\n    } else if (\n      positioning == 'bottom-center' ||\n      positioning == 'center-center' ||\n      positioning == 'top-center'\n    ) {\n      posX = '-50%';\n    }\n    if (\n      positioning == 'bottom-left' ||\n      positioning == 'bottom-center' ||\n      positioning == 'bottom-right'\n    ) {\n      posY = '-100%';\n    } else if (\n      positioning == 'center-left' ||\n      positioning == 'center-center' ||\n      positioning == 'center-right'\n    ) {\n      posY = '-50%';\n    }\n    const transform = `translate(${posX}, ${posY}) translate(${x}, ${y})`;\n    if (this.rendered.transform_ != transform) {\n      this.rendered.transform_ = transform;\n      style.transform = transform;\n    }\n  }\n\n  /**\n   * returns the options this Overlay has been created with\n   * @return {Options} overlay options\n   */\n  getOptions() {\n    return this.options;\n  }\n}\n\nexport default Overlay;\n"],"names":["cloneFeature","geojson","cloned","type","Object","keys","forEach","key","properties","cloneProperties","geometry","cloneGeometry","value","Array","isArray","map","item","geom","bbox","geometries","g","coordinates","deepSlice","coords","slice","coord","Error","features","feature","cloneFeatureCollection","origin","distance","bearing","options","wasNegativeDistance","distanceInMeters","convertLength","Math","abs","units","getCoord","destination","radius","undefined","earthRadius","Number","delta","lambda1","PI","phi1","degreesToRadians","theta","DeltaPhi","cos","phi2","DeltaPsi","log","tan","q","DeltaLambda","sin","calculateRhumbDestination","point","direction","isObject","zTranslation","mutate","isNaN","clone","coordEach","pointCoords","newCoords","getCoords","rhumbDestination","length","Property","Overlay","on","once","un","id","insertFirst","stopEvent","element","document","createElement","className","CLASS_SELECTABLE","style","position","pointerEvents","autoPan","rendered","transform_","visible","mapPostrenderListenerKey","addChangeListener","handleElementChanged","handleMapChanged","handleOffsetChanged","handlePositionChanged","handlePositioningChanged","setElement","setOffset","offset","setPositioning","positioning","setPosition","this","get","removeChildren","getElement","appendChild","removeNode","unlistenByKey","getMap","listen","MapEventType","render","updatePixelPosition","container","getOverlayContainerStopEvent","getOverlayContainer","insertBefore","childNodes","performAutoPan","set","panIntoView","panIntoViewOptions","getTargetElement","mapRect","getRect","getSize","overlayRect","outerWidth","outerHeight","myMargin","margin","containsExtent","offsetLeft","offsetRight","offsetTop","offsetBottom","center","getView","getCenterInternal","centerPx","getPixelFromCoordinateInternal","newCenterPx","panOptions","animation","animateInternal","getCoordinateFromPixelInternal","duration","easing","size","box","getBoundingClientRect","offsetX","left","window","pageXOffset","offsetY","top","pageYOffset","display","getPosition","isRendered","pixel","getPixelFromCoordinate","mapSize","updateRenderedPosition","setVisible","getOffset","getPositioning","x","round","y","posX","posY","transform","BaseObject"],"sourceRoot":""}