{"version":3,"file":"static/js/4311.f74b5913.chunk.js","mappings":"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","sources":["models/DrawModel.js"],"sourcesContent":["import { Draw, Modify, Select, Translate } from \"ol/interaction\";\nimport { createBox } from \"ol/interaction/Draw\";\nimport { Vector as VectorLayer } from \"ol/layer\";\nimport VectorSource from \"ol/source/Vector\";\nimport { Icon, Stroke, Style, Circle, Fill, Text } from \"ol/style\";\nimport { Circle as CircleGeometry, LineString } from \"ol/geom\";\nimport { fromCircle } from \"ol/geom/Polygon\";\nimport { MultiPoint, Point } from \"ol/geom\";\nimport Overlay from \"ol/Overlay\";\nimport GeoJSON from \"ol/format/GeoJSON\";\nimport transformTranslate from \"@turf/transform-translate\";\nimport { getArea as getExtentArea, getCenter, getWidth } from \"ol/extent\";\nimport { Feature } from \"ol\";\nimport { handleClick } from \"./Click\";\n\n/*\n * A model supplying useful Draw-functionality.\n * Required settings:\n * - layerName: (string): The name of the layer that initially should be connected to the Draw-model.\n *   If it already exists a layer in the map with the same name, the model will be connected\n *   to that layer. Otherwise, a new vector-layer will be created and added to the map.\n * - map: (olMap): The current map-object.\n *\n * Optional settings:\n * - observer: (Observer): An observer on which the drawModel can publish events, for example when a geometry has been deleted.\n * - observerPrefix (String): A string acting as a prefix on all messages published on the observer.\n * - modifyDefaultEnabled: (Boolean): States if the Modify-interaction be enabled when the Edit-interaction is enabled.\n * - translateDefaultEnabled: (Boolean): States if the Translate-interaction should be enabled when the Move-interaction is enabled.\n *\n * Exposes a couple of methods:\n * - refreshFeaturesTextStyle(): Refreshes the text-style on all features in the draw-source.\n * - refreshDrawLayer(): Redraws all features in the draw-layer.\n * - addFeature(feature): Adds the supplied feature to the draw-source.\n * - duplicateFeature(feature): Duplicates the supplied feature and adds it to the draw-source.\n * - removeFeature(feature): Removes the supplied feature from the draw-source.\n * - getCurrentExtent(): Returns the current extent of the current draw-layer.\n * - getCurrentLayerName(): Returns the name of the layer currently connected to the draw-model.\n * - removeDrawnFeatures():  Removes all drawn features from the current draw-source.\n * - setLayer(layerName <string>): Sets (or creates) the layer that should be connected to the draw-model.\n * - toggleDrawInteraction(drawType, settings): Accepts a string with the drawType and an object containing settings.\n * - zoomToCurrentExtent(): Fits the map-view to the current extent of the current draw-source.\n * - getRGBAString(RGBA-object <object>): Accepts an object with r-, g-, b-, and a-properties and returns the string representation.\n * - parseColorString(hex/rgba-string <string>): Accepts a string and returns an object with r-, g-, b-, and a-properties.\n * - getCurrentVectorSource(): Returns the vector-source currently connected to the draw-model.\n * - get/set drawStyleSettings(): Get or set the style settings used by the draw-model.\n * - get/set showDrawTooltip(): Get or set wether a tooltip should be shown when drawing.\n * - get/set modifyActive(): Get or set wether the Modify-interaction should be active or not.\n * - get/set translateActive(): Get or set wether the Translate-interaction should be active or not.\n * - get/set measurementSettings(): Get or set the measurement-settings (units, show-area etc.)\n * - get/set circleRadius(): Get or set the radius of the circle.\n */\nclass DrawModel {\n  #map;\n  #layerName;\n  #geoJSONParser;\n  #observer;\n  #observerPrefix;\n  #drawSource;\n  #drawLayer;\n  #currentExtent;\n  #drawTooltipElement;\n  #drawTooltipElementStyle;\n  #drawTooltip;\n  #currentPointerCoordinate;\n  #showDrawTooltip;\n  #measurementSettings;\n  #drawStyleSettings;\n  #textStyleSettings;\n  #drawInteraction;\n  #removeInteractionActive;\n  #editInteractionActive;\n  #featureChosenForEdit;\n  #moveInteractionActive;\n  #selectInteraction;\n  #translateInteraction;\n  #modifyInteraction;\n  #keepModifyActive;\n  #keepTranslateActive;\n  #customHandleDrawStart;\n  #customHandleDrawEnd;\n  #customHandlePointerMove;\n  #customHandleAddFeature;\n  #highlightFillColor;\n  #highlightStrokeColor;\n  #circleRadius;\n  #circleInteractionActive;\n  #selectInteractionActive;\n\n  constructor(settings) {\n    // Let's make sure that we don't allow initiation if required settings\n    // are missing.\n    if (!settings.map || !settings.layerName) {\n      return this.#handleInitiationParametersMissing();\n    }\n    // Make sure that we keep track of the supplied settings.\n    this.#map = settings.map;\n    this.#layerName = settings.layerName;\n    // We're gonna need a GeoJSON-parser with the maps projection set.\n    this.#geoJSONParser = new GeoJSON({\n      featureProjection: this.#map.getView().getProjection(),\n    });\n    // An observer might be supplied. If it is, the drawModel will publish messages when features are deleted etc.\n    this.#observer = settings.observer || null;\n    // There might be an \"observerPrefix\" (string) passed. States a string\n    // which will act as a prefix on all messages published on the\n    // supplied observer.\n    this.#observerPrefix = this.#getObserverPrefix(settings);\n    this.#measurementSettings =\n      settings.measurementSettings ?? this.#getDefaultMeasurementSettings();\n    this.#drawStyleSettings =\n      settings.drawStyleSettings ?? this.#getDefaultDrawStyleSettings();\n    this.#textStyleSettings =\n      settings.textStyleSettings ?? this.#getDefaultTextStyleSettings();\n    // We are going to be keeping track of the current extent of the draw-source...\n    this.#currentExtent = null;\n    // And the current draw interaction.\n    this.#drawInteraction = null;\n    // We also have to make sure to keep track of if any other interaction is active.\n    // E.g. \"Remove\", or \"Edit\".\n    this.#removeInteractionActive = false;\n    this.#editInteractionActive = false;\n    this.#moveInteractionActive = false;\n    this.#modifyInteraction = null;\n    this.#keepModifyActive = settings.modifyDefaultEnabled ?? false;\n    this.#translateInteraction = null;\n    this.#keepTranslateActive = settings.translateDefaultEnabled ?? true;\n    this.#selectInteraction = null;\n    this.#featureChosenForEdit = null;\n    // We're also keeping track of the tooltip-settings\n    this.#showDrawTooltip = settings.showDrawTooltip ?? true;\n    this.#drawTooltip = null;\n    this.#currentPointerCoordinate = null;\n    this.#drawTooltipElement = null;\n    this.#drawTooltipElementStyle =\n      \"position: relative; background: rgba(0, 0, 0, 0.5); border-radius: 4px; color: white; padding: 4px 8px; opacity: 0.7; white-space: nowrap;\";\n    // There might be some custom event-listeners passed when initiating the draw interaction,\n    // we have to keep track of them.\n    this.#customHandleDrawStart = null;\n    this.#customHandleDrawEnd = null;\n    this.#customHandlePointerMove = null;\n    this.#customHandleAddFeature = null;\n    this.#highlightFillColor = \"rgba(35,119,252,1)\";\n    this.#highlightStrokeColor = \"rgba(255,255,255,1)\";\n    this.#circleRadius = 0;\n    this.#selectInteractionActive = false;\n\n    // A Draw-model is not really useful without a vector-layer, let's initiate it\n    // right away, either by creating a new layer, or connect to an existing layer.\n    this.#initiateDrawLayer();\n    // We also have to initiate the element for the draw-tooltip\n    this.#createDrawTooltip();\n  }\n\n  // Returns the supplied observerPrefix from the supplied settings or null if none was supplied.\n  #getObserverPrefix = (settings) => {\n    return typeof settings.observerPrefix === \"string\"\n      ? settings.observerPrefix\n      : null;\n  };\n\n  // Helper function that accepts an object containing two parameters:\n  // - subject: (string): The subject to be published on the observer\n  // - payLoad: (any): The payload to send when publishing.\n  #publishInformation = ({ subject, payLoad }) => {\n    // If no observer has been set-up, or if the subject is missing, we abort\n    if (!this.#observer || !subject) {\n      return;\n    }\n    // Otherwise we create the prefixed-subject to send. (The drawModel might have\n    // been initiated with a prefix that should be added on all subjects).\n    const prefixedSubject = this.#observerPrefix\n      ? `${this.observerPrefix}.${subject}`\n      : subject;\n    // Then we publish the event!\n    this.#observer.publish(prefixedSubject, payLoad);\n  };\n\n  // Returns the default style settings used by the draw-model.\n  #getDefaultDrawStyleSettings = () => {\n    const strokeColor = \"rgba(74,74,74,0.5)\";\n    const strokeDash = null;\n    const strokeWidth = 2;\n    const fillColor = \"rgba(255,255,255,0.07)\";\n    return {\n      strokeColor: strokeColor,\n      lineDash: strokeDash,\n      strokeWidth: strokeWidth,\n      fillColor: fillColor,\n    };\n  };\n\n  // Returns the default settings used to display measurement-labels\n  #getDefaultMeasurementSettings = () => {\n    return {\n      showText: false,\n      showArea: false,\n      showPerimeter: false,\n      areaUnit: \"AUTO\",\n      lengthUnit: \"AUTO\",\n      precision: 0,\n    };\n  };\n\n  // Returns the default text-style settings used by the draw-model.\n  #getDefaultTextStyleSettings = () => {\n    const foregroundColor = \"#FFFFFF\";\n    const backgroundColor = \"#000000\";\n    const size = 14;\n    return { foregroundColor, backgroundColor, size };\n  };\n\n  // If required parameters are missing, we have to make sure we abort the\n  // initiation of the draw-model.\n  #handleInitiationParametersMissing = () => {\n    throw new Error(\n      \"Failed to initiate Draw-model, - required parameters missing. \\n Required parameters: map, layerName\"\n    );\n  };\n\n  // We have to initiate a vector layer that can be used by the draw-model\n  #initiateDrawLayer = () => {\n    if (this.#vectorLayerExists()) {\n      return this.#connectExistingVectorLayer();\n    }\n    return this.#createNewDrawLayer();\n  };\n\n  // Checks wether the layerName supplied when initiating the Draw-model\n  // corresponds to an already existing vector-layer.\n  #vectorLayerExists = () => {\n    // Get all the layers from the map\n    const allMapLayers = this.#getAllMapLayers();\n    // Check wether any of the layers has the same name (type)\n    // as the supplied layerName.\n    // Also makes sure that the found layer is a vectorLayer. (We cannot\n    // add features to an imageLayer...).\n    return allMapLayers.some((layer) => {\n      return this.#layerHasCorrectNameAndType(layer);\n    });\n  };\n\n  // Returns all layers connected to the map-object supplied\n  // when initiating the model.\n  #getAllMapLayers = () => {\n    return this.#map.getLayers().getArray();\n  };\n\n  // Checks wether the name (type) of the supplied layer matches\n  // the layerName supplied when initiating the model. Also makes\n  // sure that the layer is a vectorLayer.\n  #layerHasCorrectNameAndType = (layer) => {\n    return layer.get(\"name\") === this.#layerName && this.#isVectorLayer(layer);\n  };\n\n  // Checks wether the supplied layer is a vectorLayer or not.\n  #isVectorLayer = (layer) => {\n    return layer instanceof VectorLayer;\n  };\n\n  // Connects the private fields of the draw-model to an already existing\n  // vectorLayer.\n  #connectExistingVectorLayer = () => {\n    // Get all the layers from the map\n    const allMapLayers = this.#getAllMapLayers();\n    // Then we'll grab the layer corresponding to the supplied layerName.\n    const connectedLayer = allMapLayers.find((layer) => {\n      return this.#layerHasCorrectNameAndType(layer);\n    });\n    // Then we'll set the private fields\n    this.#drawLayer = connectedLayer;\n    this.#drawSource = connectedLayer.getSource();\n  };\n\n  // Creates a new vector layer that can be used by the draw-model\n  #createNewDrawLayer = () => {\n    // Let's grab a vector-source.\n    this.#drawSource = this.#getNewVectorSource();\n    // Then we'll create the layer\n    this.#drawLayer = this.#getNewVectorLayer(this.#drawSource);\n    // Make sure to set a unique name\n    this.#drawLayer.set(\"name\", this.#layerName);\n    // We're also gonna have to set the queryable-property to true\n    // so that we can enable \"Select\" on the layer.\n    this.#drawLayer.set(\"queryable\", true);\n    // Then we can add the layer to the map.\n    this.#map.addLayer(this.#drawLayer);\n  };\n\n  // Creates the element and overlay used to display the area of the feature\n  // currently being drawn.\n  #createDrawTooltip = () => {\n    // If the element already exists in the dom (which it will if #drawTooltipElement\n    //  isn't nullish), we must make sure to remove it.\n    this.#removeEventualDrawTooltipElement();\n    // Let's crete a element that we can use in the overlay.\n    this.#drawTooltipElement = document.createElement(\"div\");\n    // Let's style the element a bit so it looks prettier...\n    this.#drawTooltipElement.setAttribute(\n      \"style\",\n      this.#drawTooltipElementStyle\n    );\n    // Then let's create the overlay...\n    this.#drawTooltip = new Overlay({\n      element: this.#drawTooltipElement,\n      offset: [30, -5],\n      positioning: \"bottom-center\",\n    });\n    // And add it to the map!\n    this.#map.addOverlay(this.#drawTooltip);\n  };\n\n  // We have to make sure that we remove eventual unused elements\n  // from the dom tree so they're not lurking around.\n  #removeEventualDrawTooltipElement = () => {\n    // Before we do anything else, we make sire that there actually is\n    // an element present.\n    if (this.#drawTooltipElement) {\n      // Then we can remove it\n      this.#drawTooltipElement.parentNode.removeElement(\n        this.#drawTooltipElement\n      );\n      // And clear the variable\n      this.#drawTooltipElement = null;\n    }\n  };\n\n  // Returns the style that should be used on the drawn features\n  #getFeatureStyle = (feature, settingsOverride) => {\n    if (feature.get(\"HIDDEN\") === true) {\n      !feature.get(\"STYLE_BEFORE_HIDE\") &&\n        feature.set(\"STYLE_BEFORE_HIDE\", feature.getStyle());\n      return new Style({});\n    }\n    // If we're dealing with \"Arrow\" we'll return a special style array\n    if (feature?.get(\"DRAW_METHOD\") === \"Arrow\") {\n      return this.#getArrowStyle(feature, settingsOverride);\n    }\n    // Otherwise we'll grab the 'current' style. The 'current' style might be\n    // stored in the 'STYLE_BEFORE_HIDE' property (and feature.getStyle() will\n    // return an empty style). This case happens when the feature has been hid, and\n    // is now to be shown again. For all the 'ordinary' cases, this property will be null\n    // and wont affect the feature-style.\n    const currentStyle = feature.get(\"STYLE_BEFORE_HIDE\") || feature.getStyle();\n    feature.set(\"STYLE_BEFORE_HIDE\", null);\n    // Let's grab the standard draw (or the currently set) style as a baseline.\n    // The standard style can be overridden if the override is supplied. This is a real mess,\n    // since OL might decide to apply a style-array sometimes (in that case we want the fist style\n    // from the style-array) and sometimes its not an array.\n    const baseLineStyle = settingsOverride\n      ? this.#getDrawStyle(settingsOverride)\n      : currentStyle\n      ? Array.isArray(currentStyle)\n        ? currentStyle[0]\n        : currentStyle\n      : this.#getDrawStyle();\n    // If we're dealing with a text-feature, we don't want an image-style.\n    feature.get(\"DRAW_METHOD\") === \"Text\" && baseLineStyle.setImage(null);\n    // ILet's create a text-style. (Remember that this might be null, depending\n    // on the feature-text-settings, see more info in the method itself).\n    const textStyle = this.#getFeatureTextStyle(feature);\n    // Apply the text-style to the baseline style...\n    baseLineStyle.setText(textStyle);\n    // If the \"EDIT_ACTIVE\"-property is set (meaning that the feature has been selected for\n    // editing of its color etc) we have to return the baseline-style along with a highligh-style.\n    if (feature.get(\"EDIT_ACTIVE\") === true) {\n      return [baseLineStyle, this.#getNodeHighlightStyle(feature)];\n    } else {\n      // If its not set, we just return the baseline style!\n      return baseLineStyle;\n    }\n  };\n\n  // Method returning if we're supposed to be showing text on the feature\n  // or not. We're showing text in two cases: One: if the feature is of text-type,\n  // or two: if we're supposed to be showing feature measurements. If the feature is\n  // of arrow-type, we're never showing text.\n  #shouldShowText = (feature) => {\n    if (!feature) {\n      console.warn(\n        \"Could not evaluate '#shouldShowText' since no feature was supplied.\"\n      );\n      return false;\n    }\n    // The \"SHOW_TEXT\" prop can be toggled by the user allowing them to hide all texts.\n    if (feature.get(\"SHOW_TEXT\") === false) {\n      return false;\n    }\n    // Let's get the feature draw-method\n    const featureDrawMethod =\n      feature.get(\"DRAW_METHOD\") || feature.get(\"geometryType\");\n    // And check if we're supposed to be showing text or not.\n    // (We're never showing text on arrow-features, and text-features override\n    // the measurement-settings, since the text-features would be useless\n    // if the text wasn't shown).\n    return (\n      featureDrawMethod !== \"Arrow\" &&\n      (this.#measurementSettings.showText || featureDrawMethod === \"Text\")\n    );\n  };\n\n  // Returns a text-style that shows the tooltip-label\n  // (i.e. the area of the feature in a readable format).\n  // *If the measurement-label is supposed to be shown!*\n  #getFeatureTextStyle = (feature) => {\n    // First we have to make sure we're supposed to be showing text on the feature.\n    const shouldShowText = this.#shouldShowText(feature);\n    // If we're not supposed to be showing any text, we can just return null\n    if (!shouldShowText) {\n      return null;\n    }\n    // Before we create the text-style we have to check if we,re dealing with a\n    // point. If we are, we have to make sure to offset the text in the negative y-direction.\n    const featureIsPoint = feature?.getGeometry() instanceof Point;\n    // We also have to check if we're dealing with a text-feature or not\n    const featureIsTextType = feature?.get(\"DRAW_METHOD\") === \"Text\";\n    // Then we can create and return the style\n    return new Text({\n      textAlign: \"center\",\n      textBaseline: \"middle\",\n      font: `${\n        featureIsTextType\n          ? feature.get(\"TEXT_SETTINGS\")?.size ?? this.#textStyleSettings.size\n          : 12\n      }pt sans-serif`,\n      fill: new Fill({\n        color: featureIsTextType\n          ? feature.get(\"TEXT_SETTINGS\")?.foregroundColor ??\n            this.#textStyleSettings.foregroundColor\n          : \"#FFF\",\n      }),\n      text: this.#getFeatureLabelText(feature),\n      overflow: true,\n      stroke: new Stroke({\n        color: featureIsTextType\n          ? feature.get(\"TEXT_SETTINGS\")?.backgroundColor ??\n            this.#textStyleSettings.backgroundColor\n          : \"rgba(0, 0, 0, 0.5)\",\n        width: 3,\n      }),\n      offsetX: 0,\n      offsetY: featureIsPoint && !featureIsTextType ? -15 : 0,\n      rotation: 0,\n      scale: 1,\n    });\n  };\n\n  #getArrowBaseStyle = (settings) => {\n    // First we'll grab the feature base-style\n    const baseStyle = this.#getDrawStyle(settings);\n    // Then we'll alter the base-style a bit... We don't want to apply\n    // eventual line-dash, and we also want a hard-coded stroke-width.\n    const baseStroke = baseStyle.getStroke();\n    baseStroke.setWidth(5);\n    baseStroke.setLineDash(null);\n    // Then we return the altered base-style\n    return baseStyle;\n  };\n\n  // Returns a svg-string that is used to display arrows in the draw-source.\n  #createArrowSvg = (color) => {\n    const svgString = `<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\" width=\"32pt\" height=\"32pt\" fill=\"${color}\"><path d=\"M 1 5 L 1 5 L 1 13 L 1 21 L 1 21 L 12 13\"/></svg>`;\n    return `data:image/svg+xml;base64,${window.btoa(svgString)}`; // We need base64 for kml-exports to work.\n  };\n\n  // Returns a style array that is used to style arrow features.\n  // (All other features consist of a single style-object).\n  #getArrowStyle = (feature, settings) => {\n    // First we'll extract the current style. We only want the current style if it is\n    // an array! Otherwise we're not dealing with an arrow-style... (Arrow-style should always be an array).\n    const currentStyle = Array.isArray(feature.getStyle())\n      ? feature.getStyle()\n      : null;\n    // Then we'll grab the arrow base-style, which should be the first style in the current\n    // style-array. If that style is missing, we'll create a new one.\n    const baseStyle = settings\n      ? this.#getArrowBaseStyle(settings)\n      : currentStyle\n      ? currentStyle[0]\n      : this.#getArrowBaseStyle();\n    // We have to extract the base-color as well, so that we can create an arrow-head with\n    // the correct color.\n    const baseColor = baseStyle.getStroke()?.getColor() ?? null;\n    // Then we'll add the base-style to the styles-array\n    const styles = [baseStyle];\n    // Then we'll add the arrow-head at the end of every line-segment.\n    feature?.getGeometry().forEachSegment((start, end) => {\n      // We'll have to rotate the arrow-head, let's calculate the\n      // line-segments rotation.\n      const dx = end[0] - start[0];\n      const dy = end[1] - start[1];\n      const rotation = Math.atan2(dy, dx);\n      // Then we'll push a style for each arrow-head.\n      styles.push(\n        new Style({\n          geometry: new Point(end),\n          image: new Icon({\n            src: this.#createArrowSvg(\n              settings\n                ? settings.strokeStyle.color\n                : baseColor\n                ? baseColor\n                : this.#drawStyleSettings.strokeColor\n            ),\n            anchor: [0.38, 0.53],\n            rotateWithView: true,\n            rotation: -rotation,\n          }),\n        })\n      );\n    });\n    // And finally return the style-array.\n    return styles;\n  };\n\n  // Creates a highlight style (a style marking the coordinates of the supplied feature).\n  #getNodeHighlightStyle = (feature) => {\n    try {\n      return new Style({\n        image: new Circle({\n          radius: 5,\n          fill: new Fill({\n            color: this.#highlightFillColor,\n          }),\n          stroke: new Stroke({ color: this.#highlightStrokeColor, width: 2 }),\n        }),\n        geometry: () => {\n          const coordinates = this.#getFeatureCoordinates(feature);\n          return new MultiPoint(coordinates);\n        },\n      });\n    } catch (error) {\n      console.error(`Could not create highlight style. Error: ${error}`);\n      return null;\n    }\n  };\n\n  // Returns an array of arrays with the coordinates of the supplied feature\n  #getFeatureCoordinates = (feature) => {\n    // First, we have to extract the feature geometry\n    const geometry = feature.getGeometry();\n    // Then we'll have to extract the feature type, since we have to extract the\n    // coordinates in different ways, depending on the geometry type.\n    const geometryType = geometry.getType();\n    // Then we'll use a switch-case to make sure we return the coordinates in\n    // the correct format.\n    switch (geometryType) {\n      case \"Circle\":\n        // If we're dealing with a circle, we'll create a simplified geometry\n        // with 8 points, which we can use to highlight some of the \"nodes\" of\n        // the circle. GetCoordinates returns the coordinates in an extra wrapping\n        // array (for polygons), so let's return the first element.\n        return fromCircle(geometry, 8).getCoordinates()[0];\n      case \"LineString\":\n        // GetCoordinates returns an array of arrays with coordinates for LineStrings,\n        // so we can return it as-is.\n        return geometry.getCoordinates();\n      case \"Point\":\n        // GetCoordinates returns an array with the coordinates for points,\n        // so we have to wrap that array in an array before returning.\n        return [geometry.getCoordinates()];\n      default:\n        // The default catches Polygons, which are wrapped in an \"extra\" array, so let's\n        // return the first element.\n        return geometry.getCoordinates()[0];\n    }\n  };\n\n  // Returns the area, perimeter, and/or length of the supplied feature in a readable format.\n  #getFeatureMeasurementLabel = (feature, labelType) => {\n    // First we must get the feature measurements (The returned measurements will differ\n    // Depending on if we're dealing with Point, LineString, or surface).\n    const measurements = this.#getFeatureMeasurements(feature);\n    // Then we'll reduce the measurements down to a string that we can show.\n    return measurements.reduce((acc, curr) => {\n      switch (curr.type) {\n        case \"COORDINATES\":\n          return (acc += `N: ${Math.round(curr.value[1])} E: ${Math.round(\n            curr.value[0]\n          )}`);\n        case \"AREA\":\n        case \"PERIMETER\":\n        case \"LENGTH\":\n          return (acc += this.#getFormattedMeasurementString(curr, labelType));\n        default:\n          return acc;\n      }\n    }, \"\");\n  };\n\n  #getFormattedMeasurementString = (measurement, labelType) => {\n    // Let's destruct some measurement-information that we can\n    // use to construct the measurement-string.\n    const { type, value, prefix } = measurement;\n    // We have to make sure that we're supposed to show the measurement-text.\n    // This is controlled in the measurement-settings, but is also affected by\n    // the supplied type (if we're creating a tooltip, we're always showing everything!).\n    const showMeasurement =\n      labelType === \"TOOLTIP\" ||\n      (type === \"LENGTH\" && this.#measurementSettings.showLength) ||\n      (type === \"AREA\" && this.#measurementSettings.showArea) ||\n      (type === \"PERIMETER\" && this.#measurementSettings.showPerimeter);\n    // If we're not supposed to be showing the measurement, lets return an empty string.\n    if (!showMeasurement) {\n      return \"\";\n    }\n    // Otherwise we'll handle the formatting according to the labelFormat set by the user\n    switch (this.#getLabelFormatFromMeasurementType(type)) {\n      case \"AUTO\":\n        const formatted = this.#shouldFormatToKm(value, type)\n          ? this.#getKilometerMeasurementString(value, type)\n          : this.#getMeasurementString(value, type);\n        return `${prefix} ${formatted}`;\n      case \"KM\":\n      case \"KM2\":\n        // If the format is \"KM2\", we'll show the measurement in km\n        // (Or km if we're measuring length). Rounded to show 3 decimals.\n        return `${prefix} ${this.#getKilometerMeasurementString(value, type)}`;\n      case \"HECTARE\":\n        // If the format is \"HECTARE\" we will show the measurement in hectare\n        // if we're dealing with a surface. If we're dealing with a lineString\n        // we will return the measurement with \"M2\" format.\n        return `${prefix} ${this.#getHectareMeasurementString(value, type)}`;\n      default:\n        // Otherwise m (or m) will do. (Displayed in local format).\n        return `${prefix} ${this.#getMeasurementString(value, type)}`;\n    }\n  };\n\n  #getLabelFormatFromMeasurementType = (type) => {\n    switch (type) {\n      case \"LENGTH\":\n      case \"PERIMETER\":\n        return this.#measurementSettings.lengthUnit;\n      default:\n        return this.#measurementSettings.areaUnit;\n    }\n  };\n\n  // Checks if the supplied value and type should be formatted to km or not.\n  #shouldFormatToKm = (value, type) => {\n    // If the format is AUTO, we're checking if the measurement is large\n    // enough to show it in kilometers or not. First, we need to set\n    // the cutoff points for the kilometer display.\n    const lengthCutOff = 1e3;\n    const areaCutOff = 1e6;\n    switch (type) {\n      case \"LENGTH\":\n      case \"PERIMETER\":\n        return value > lengthCutOff;\n      default:\n        return value > areaCutOff;\n    }\n  };\n\n  // Returns the label text that should be shown on the feature.\n  // Usually the text is constructed by the measurement of the feature,\n  // but if the feature is of text-type, we show the user-added-text.\n  #getFeatureLabelText = (feature) => {\n    // Are we dealing with a text-feature? Let's return the user-\n    // added-text.\n    if (feature.get(\"DRAW_METHOD\") === \"Text\") {\n      return feature.get(\"USER_TEXT\") ?? \"\";\n    }\n    // There might be a title present on the feature, if there is, we'll want\n    // to display it.\n    const featureTitle = feature.get(\"FEATURE_TITLE\") ?? \"\";\n    // We'll also have to grab the eventual measurement-label\n    const measurementLabel = this.#measurementSettings.showText\n      ? this.#getFeatureMeasurementLabel(feature, \"LABEL\")\n      : \"\";\n    // Finally, we can return the eventual title, and the eventual measurement-label combined.\n    return featureTitle.length > 0\n      ? `${featureTitle}${\n          measurementLabel.length > 0 ? \"\\n\" : \"\"\n        }${measurementLabel}`\n      : measurementLabel;\n  };\n\n  // Returns the supplied measurement as a kilometer-formatted string.\n  // If we're measuring area, km is returned, otherwise, km is returned.\n  #getKilometerMeasurementString = (featureMeasure, type) => {\n    // The precision can be changed by the user and is set in the measurement-settings.\n    const precision = this.#measurementSettings.precision ?? 0;\n    switch (type) {\n      case \"LENGTH\":\n      case \"PERIMETER\":\n        return `${Number(\n          (featureMeasure / 1e3).toFixed(precision)\n        ).toLocaleString()} km`;\n      default:\n        return `${Number(\n          (featureMeasure / 1e6).toFixed(precision)\n        ).toLocaleString()} km`;\n    }\n  };\n\n  // Returns the measurement in hectare if we're dealing with a surface, and if\n  // we're dealing with a line-string we return the measurement in metres.\n  #getHectareMeasurementString = (featureMeasure, type) => {\n    // The precision can be changed by the user and is set in the measurement-settings.\n    const precision = this.#measurementSettings.precision ?? 0;\n    switch (type) {\n      case \"LENGTH\":\n      case \"PERIMETER\":\n        return this.#getMeasurementString(featureMeasure, type);\n      default:\n        return `${Number(\n          (featureMeasure / 1e4).toFixed(precision)\n        ).toLocaleString()} ha`;\n    }\n  };\n\n  // Returns the supplied measurement as a locally formatted string.\n  // If we're measuring area m is returned, otherwise, m is returned.\n  #getMeasurementString = (featureMeasure, type) => {\n    // The precision can be changed by the user and is set in the measurement-settings.\n    const precision = this.#measurementSettings.precision ?? 0;\n    switch (type) {\n      case \"LENGTH\":\n      case \"PERIMETER\":\n        return `${Number(\n          featureMeasure.toFixed(precision)\n        ).toLocaleString()} m`;\n      default:\n        return `${Number(\n          featureMeasure.toFixed(precision)\n        ).toLocaleString()} m`;\n    }\n  };\n\n  // Calculates the area, length, or placement of the supplied feature.\n  // Accepts an OL-feature, and is tested for Circle, LineString, Point, and Polygon.\n  #getFeatureMeasurements = (feature) => {\n    // Let's get the geometry-type to begin with, we are going\n    // to be handling points, line-strings, and surfaces differently.\n    const geometry = feature.getGeometry();\n    // If we're dealing with a point, we simply return the coordinates of the point.\n    if (geometry instanceof Point) {\n      return [\n        { type: \"COORDINATES\", value: geometry.getCoordinates(), prefix: \"\" },\n      ];\n    }\n    // If the user has chosen to only show the area (and not the perimeter), we don't\n    // need to show the area-prefix. The area-prefix should only be shown if both area and\n    // perimeter is chosen to be shown.\n    const showAreaPrefix =\n      this.#measurementSettings.showArea &&\n      this.#measurementSettings.showPerimeter;\n    // Apparently the circle geometry instance does not expose a\n    // getArea method. Here's a quick fix. (Remember that this area\n    // is only used as an heads-up for the user.)\n    if (geometry instanceof CircleGeometry) {\n      const radius = geometry.getRadius();\n      return [\n        {\n          type: \"AREA\",\n          value: Math.pow(radius, 2) * Math.PI,\n          prefix: `${showAreaPrefix ? \"Area:\" : \"\"}`,\n        },\n        {\n          type: \"PERIMETER\",\n          value: radius,\n          prefix: \"\\n Radie:\",\n        },\n      ];\n    }\n    // If we're dealing with a line we cannot calculate an area,\n    // instead, we only calculate the length.\n    if (geometry instanceof LineString) {\n      return [{ type: \"LENGTH\", value: geometry.getLength(), prefix: \"\" }];\n    }\n    // If we're not dealing with a point, circle, or a line, we are probably dealing\n    // with a polygon. For the polygons, we want to return the area and perimeter.\n    return [\n      {\n        type: \"AREA\",\n        value: geometry?.getArea() || 0,\n        prefix: `${showAreaPrefix ? \"Area:\" : \"\"}`,\n      },\n      {\n        type: \"PERIMETER\",\n        value: this.#getPolygonPerimeter(geometry),\n        prefix: \"\\n Omkrets:\",\n      },\n    ];\n  };\n\n  // Returns the perimeter of the supplied polygon-geometry\n  #getPolygonPerimeter = (geometry) => {\n    try {\n      // To get the perimeter, we have to get the coordinates of the\n      // outer (0) linear-ring of the supplied geometry. If we fail to extract these\n      // coordinates, we set the linear-ring-coords to null.\n      const linearRingCoords =\n        geometry?.getLinearRing(0)?.getCoordinates() || null;\n      // If no coords were found, we simply return an area of 0.\n      if (!linearRingCoords) {\n        return 0;\n      }\n      // If some coords were found, we can construct a Line-string, and get the length\n      // of that line-string!\n      return new LineString(linearRingCoords)?.getLength() || 0;\n    } catch (error) {\n      // If we fail somewhere, we return 0. Would be better with more handling here!\n      return 0;\n    }\n  };\n\n  // Returns an OL style to be used in the draw-interaction.\n  #getDrawStyle = (settings) => {\n    return new Style({\n      stroke: this.#getDrawStrokeStyle(settings),\n      fill: this.#getDrawFillStyle(settings),\n      image: this.#getDrawImageStyle(settings),\n    });\n  };\n\n  // Returns the stroke style (based on the style settings)\n  #getDrawStrokeStyle = (settings) => {\n    return new Stroke({\n      color: settings\n        ? settings.strokeStyle.color\n        : this.#drawStyleSettings.strokeColor,\n      lineDash: settings\n        ? settings.strokeStyle.dash\n        : this.#drawStyleSettings.lineDash,\n      width: settings\n        ? settings.strokeStyle.width\n        : this.#drawStyleSettings.strokeWidth,\n    });\n  };\n\n  // Returns the fill style (based on the style settings)\n  #getDrawFillStyle = (settings) => {\n    return new Fill({\n      color: settings\n        ? settings.fillStyle.color\n        : this.#drawStyleSettings.fillColor,\n    });\n  };\n\n  // Returns the image style (based on the style settings)\n  #getDrawImageStyle = (settings) => {\n    return new Circle({\n      radius: 6,\n      stroke: new Stroke({\n        color: settings\n          ? settings.strokeStyle.color\n          : this.#drawStyleSettings.strokeColor,\n        width: settings\n          ? settings.strokeStyle.width\n          : this.#drawStyleSettings.strokeWidth,\n        lineDash: settings\n          ? settings.strokeStyle.dash\n          : this.#drawStyleSettings.lineDash,\n      }),\n      fill: new Fill({\n        color: settings\n          ? settings.fillStyle.color\n          : this.#drawStyleSettings.fillColor,\n      }),\n    });\n  };\n\n  // Extracts the fill-style from the supplied feature-style\n  #getFillStyleInfo = (featureStyle) => {\n    try {\n      // Since we might be dealing with a style-array instead of a style-object\n      // (in case of the special Arrow feature-type) we have to make sure to get\n      // the actual base-style (which is located at position 0 in the style-array).\n      const color = Array.isArray(featureStyle)\n        ? featureStyle[0]?.getFill()?.getColor()\n        : featureStyle?.getFill()?.getColor();\n      return { color: this.getRGBAString(color) };\n    } catch (error) {\n      console.error(`Failed to extract fill-style, ${error.message}`);\n      return { color: null };\n    }\n  };\n\n  // Extracts the stroke-style from the supplied feature-style\n  #getStrokeStyleInfo = (featureStyle) => {\n    try {\n      // Since we might be dealing with a style-array instead of a style-object\n      // (in case of the special Arrow feature-type) we have to make sure to get\n      // the actual base-style (which is located at position 0 in the style-array).\n      const s = Array.isArray(featureStyle)\n        ? featureStyle[0]?.getStroke()\n        : featureStyle?.getStroke();\n      const color = s?.getColor();\n      const dash = s?.getLineDash();\n      const width = s?.getWidth();\n      return {\n        color: this.getRGBAString(color),\n        dash,\n        width,\n      };\n    } catch (error) {\n      console.error(`Failed to extract stroke-style, ${error.message}`);\n      return { color: null, dash: null, width: null };\n    }\n  };\n\n  // Extracts the image-style from the supplied feature-style\n  #getImageStyleInfo = (featureStyle) => {\n    // Since we might be dealing with a style-array instead of a style-object\n    // (in case of the special Arrow feature-type) we have to make sure to get\n    // the actual base-style (which is located at position 0 in the style-array).\n    const s = Array.isArray(featureStyle)\n      ? featureStyle[0]?.getImage()\n      : featureStyle?.getImage();\n    // Let's extract the fill- and stroke-style from the image-style.\n    const fillStyle = s?.getFill?.();\n    const strokeStyle = s?.getStroke?.();\n    // Let's make sure the image-style has fill- and stroke-style before moving on\n    if (!fillStyle || !strokeStyle) {\n      return {\n        fillColor: null,\n        strokeColor: null,\n        strokeWidth: null,\n        dash: null,\n      };\n    }\n    const fillColor = fillStyle.getColor();\n    const strokeColor = strokeStyle.getColor();\n    const strokeWidth = strokeStyle.getWidth();\n    const dash = strokeStyle.getLineDash();\n    return {\n      fillColor: this.getRGBAString(fillColor),\n      strokeColor: this.getRGBAString(strokeColor),\n      strokeWidth,\n      dash,\n    };\n  };\n\n  // Extracts and returns information about the feature style.\n  extractFeatureStyleInfo = (feature) => {\n    // Let's run this in a try-catch since we cannot be sure that a\n    // real feature is supplied. (I.e. getStyle() etc. might not exist).\n    try {\n      const featureStyle = feature?.getStyle();\n      // If no feature was supplied, or if we're unable to extract the style,\n      // we return null.\n      if (!featureStyle) {\n        return { fillStyle: null, strokeStyle: null, imageStyle: null };\n      }\n      // If we were able to extract the style we can continue by extracting\n      // the fill- and stroke-style.\n      const fillStyle = this.#getFillStyleInfo(featureStyle);\n      const strokeStyle = this.#getStrokeStyleInfo(featureStyle);\n      const imageStyle = this.#getImageStyleInfo(featureStyle);\n      // And return an object containing them\n      return { fillStyle, strokeStyle, imageStyle };\n    } catch (error) {\n      console.error(`Failed to extract feature-style. Error: ${error}`);\n      return { fillStyle: null, strokeStyle: null, imageStyle: null };\n    }\n  };\n\n  // Updates the text-style on all drawn features. Used when toggling\n  // if the measurement-label should be shown or not for example.\n  #refreshFeaturesTextStyle = () => {\n    // Get all the drawn features (Except for arrows, these doesn't have any text\n    // and shouldn't be refreshed)...\n    const drawnFeatures = this.getAllDrawnFeatures().filter(\n      (f) => f.get(\"DRAW_METHOD\") !== \"Arrow\"\n    );\n    // Iterate the drawn features...\n    drawnFeatures.forEach((feature) => {\n      // Get the current style.\n      const featureStyle = feature.getStyle();\n      // Get an updated text-style (which depends on the #measurementSettings).\n      const textStyle = this.#getFeatureTextStyle(feature);\n      // Set the updated text-style on the base-style.\n      Array.isArray(featureStyle)\n        ? featureStyle[0].setText(textStyle)\n        : featureStyle.setText(textStyle);\n      // Then update the feature style.\n      feature.setStyle(featureStyle);\n    });\n  };\n\n  // Returns a new vector source.\n  #getNewVectorSource = () => {\n    return new VectorSource({ wrapX: false });\n  };\n\n  // Returns a new vector layer connected to the supplied source.\n  #getNewVectorLayer = (source) => {\n    return new VectorLayer({\n      source: source,\n      layerType: \"system\",\n      zIndex: 5000,\n      caption: \"Draw model\",\n    });\n  };\n\n  // Returns all user drawn features from the draw-source\n  getAllDrawnFeatures = () => {\n    return this.#drawSource.getFeatures().filter((feature) => {\n      return feature.get(\"USER_DRAWN\") === true;\n    });\n  };\n\n  // Fits the map to the current extent of the draw-source (with some padding).\n  #fitMapToExtent = () => {\n    this.#map.getView().fit(this.#currentExtent, {\n      size: this.#map.getSize(),\n      padding: [20, 20, 20, 20],\n      maxZoom: 7,\n    });\n  };\n\n  // Removes all event-listeners that have been set when initiating the\n  // draw interaction.\n  #removeEventListeners = () => {\n    // Remove the \"ordinary\" listeners\n    this.#drawInteraction.un(\"drawstart\", this.#handleDrawStart);\n    this.#drawInteraction.un(\"drawend\", this.#handleDrawEnd);\n    this.#drawInteraction.un(\"drawabort\", this.#handleDrawAbort);\n    this.#map.un(\"pointermove\", this.#handlePointerMove);\n    this.#drawSource.un(\"addfeature\", this.#handleDrawFeatureAdded);\n    document.removeEventListener(\"keyup\", this.#handleKeyUp);\n    // Then we'll remove the custom listeners\n    this.#removeCustomEventListeners();\n  };\n\n  // Adds all event-listeners needed for the the draw interaction.\n  #addEventListeners = (settings) => {\n    // The initiator of the draw interaction might have passed some custom functions\n    // that should be called when the appropriate event fires. We have to make sure\n    // to bind those if they exist.\n    settings && this.#addCustomEventListeners(settings);\n    // Add a listener for the draw-start-event\n    this.#drawInteraction.on(\"drawstart\", this.#handleDrawStart);\n    // Add a listener for the draw-end-event\n    this.#drawInteraction.on(\"drawend\", this.#handleDrawEnd);\n    // Add a listener for when drawing is aborted (e.g. if all points are\n    // removed by pressing esc several times).\n    this.#drawInteraction.on(\"drawabort\", this.#handleDrawAbort);\n    // We need a listener for when a feature is added to the source.\n    this.#drawSource.on(\"addfeature\", this.#handleDrawFeatureAdded);\n    // We need a listener for keyboard input. For example, pressing the escape\n    // key will allow the users to remove the last point.\n    document.addEventListener(\"keyup\", this.#handleKeyUp);\n  };\n\n  // Adds listeners that might have been passed in the settings when\n  // initiating the draw interaction.\n  #addCustomEventListeners = (settings) => {\n    // Let's update all internal fields so that we can keep track of the\n    // custom handlers.\n    this.#customHandleDrawStart = settings.handleDrawStart || null;\n    this.#customHandleDrawEnd = settings.handleDrawEnd || null;\n    this.#customHandlePointerMove = settings.handlePointerMove || null;\n    this.#customHandleAddFeature = settings.handleAddFeature || null;\n    // Then we'll add the listeners if the corresponding handler exists\n    this.#customHandleDrawStart &&\n      this.#drawInteraction.on(\"drawstart\", this.#customHandleDrawStart);\n    this.#customHandleDrawEnd &&\n      this.#drawInteraction.on(\"drawend\", this.#customHandleDrawEnd);\n    this.#customHandlePointerMove &&\n      this.#map.on(\"pointermove\", this.#customHandlePointerMove);\n    this.#customHandleAddFeature &&\n      this.#drawSource.on(\"addfeature\", this.#customHandleAddFeature);\n  };\n\n  // Removes listeners that might have been passed in the settings when\n  // initiating the draw interaction.\n  #removeCustomEventListeners = () => {\n    // Let's unbind the listers if they ever existed\n    this.#customHandleDrawStart &&\n      this.#drawInteraction.un(\"drawstart\", this.#customHandleDrawStart);\n    this.#customHandleDrawEnd &&\n      this.#drawInteraction.un(\"drawend\", this.#customHandleDrawEnd);\n    this.#customHandlePointerMove &&\n      this.#map.on(\"pointermove\", this.#customHandlePointerMove);\n    this.#customHandleAddFeature &&\n      this.#drawSource.un(\"addfeature\", this.#customHandleAddFeature);\n    // Then we have to make sure to remove the reference to the handlers.\n    this.#customHandleDrawStart = null;\n    this.#customHandleDrawEnd = null;\n    this.#customHandlePointerMove = null;\n    this.#customHandleAddFeature = null;\n  };\n\n  // This handler has a couple of jobs; add a change listener to the feature\n  // currently being drawn, and register an event-handler for pointer moves.\n  #handleDrawStart = (e) => {\n    // Let's add a handler for the pointer event to keep\n    // track of where the users pointer is located.\n    this.#map.on(\"pointermove\", this.#handlePointerMove);\n    // Then we'll add a handler handling feature changes.\n    const feature = e.feature;\n    feature.on(\"change\", this.#handleFeatureChange);\n    // Finally, we'll make sure the feature being drawn has the correct style:\n    feature.setStyle(this.#getDrawStyle());\n  };\n\n  // This handler will make sure that the overlay will be removed\n  // when the feature drawing is done.\n  #handleDrawEnd = (e) => {\n    // Let's make sure to reset the draw tooltip\n    this.#resetDrawTooltip();\n    const { feature } = e;\n    // We set the USER_DRAWN prop to true so that we can keep track\n    // of the user drawn features. We also set \"DRAW_TYPE\" so that we can\n    // handle special features, such as arrows.\n    feature.set(\"USER_DRAWN\", true);\n    feature.set(\"DRAW_METHOD\", this.#drawInteraction?.get(\"DRAW_METHOD\"));\n    feature.set(\"TEXT_SETTINGS\", this.#textStyleSettings);\n    // And set a nice style on the feature to be added.\n    feature.setStyle(this.#getFeatureStyle(feature));\n    // Make sure to remove the event-listener for the pointer-moves.\n    // (We don't want the pointer to keep updating while we're not drawing).\n    this.#map.un(\"pointermove\", this.#handlePointerMove);\n  };\n\n  // Handler that will fire when features has been modified with the modify-interaction.\n  // Makes sure to update the text-styling so that eventual measurement-label is up-to-date.\n  #handleModifyEnd = (e) => {\n    e.features.forEach((f) => {\n      // If we're dealing with arrows, we have to make sure to\n      // update the whole style, so that the arrow-head is moved.\n      if (f.get(\"DRAW_METHOD\") === \"Arrow\") {\n        this.#refreshArrowStyle(f);\n      }\n    });\n    this.#refreshFeaturesTextStyle();\n  };\n\n  // Re-calculates and re-applies the arrow style. For ordinary features this is\n  // not required, but since the arrows consists of an svg, we have to re-calculate\n  // the style to make sure the svg gets the correct color.\n  #refreshArrowStyle = (f) => {\n    try {\n      const strokeStyle = f.getStyle()[0].getStroke();\n      f.setStyle(\n        this.#getArrowStyle(f, {\n          strokeStyle: {\n            color: strokeStyle.getColor(),\n          },\n          fillStyle: { color: strokeStyle.getColor() },\n        })\n      );\n    } catch (error) {\n      console.error(`Failed to set arrow style. Error: ${error}`);\n    }\n  };\n\n  // Cleans up if the drawing is aborted.\n  #handleDrawAbort = () => {\n    this.#resetDrawTooltip();\n  };\n\n  #resetDrawTooltip = () => {\n    this.#drawTooltipElement.innerHTML = null;\n    this.#currentPointerCoordinate = null;\n    this.#drawTooltip.setPosition(this.#currentPointerCoordinate);\n  };\n\n  // This handler will make sure that we keep the measurement calculation\n  // updated during the feature changes.\n  #handleFeatureChange = (e) => {\n    // Make the measurement calculations and update the tooltip\n    const feature = e.target;\n    const toolTipText = this.#getFeatureMeasurementLabel(feature, \"TOOLTIP\");\n    this.#drawTooltipElement.innerHTML = this.#showDrawTooltip\n      ? toolTipText\n      : null;\n    this.#drawTooltip.setPosition(this.#currentPointerCoordinate);\n  };\n\n  // This handler has one job; get the coordinate from the event,\n  // and store it for later use. *But only if the draw tooltip should be active! If\n  // the draw tooltip is disabled, we set the coordinate to null*\n  #handlePointerMove = (e) => {\n    this.#currentPointerCoordinate = this.#showDrawTooltip\n      ? e.coordinate\n      : null;\n  };\n\n  // We're probably going to need a handler for when a feature is added.\n  // For now, let's publish an event on the observer.\n  #handleDrawFeatureAdded = (e) => {\n    this.#publishInformation({\n      subject: \"drawModel.featureAdded\",\n      payLoad: e.feature,\n    });\n  };\n\n  // We want to handle key-up events so that we can let the user\n  // remove the last drawn point by pressing the escape key. (And perhaps more...?)\n  #handleKeyUp = (e) => {\n    const { keyCode } = e;\n    if (keyCode === 27) {\n      this.#drawInteraction.removeLastPoint();\n    }\n  };\n\n  // Disables the current draw interaction\n  #disablePotentialInteraction = () => {\n    // First we check if any of the \"special\" interactions are active, and if they\n    // are, we disable them.\n    if (this.#removeInteractionActive) {\n      return this.#disableRemoveInteraction();\n    }\n    if (this.#editInteractionActive) {\n      return this.#disableEditInteraction();\n    }\n    if (this.#moveInteractionActive) {\n      return this.#disableMoveInteraction();\n    }\n    if (this.#selectInteractionActive) {\n      this.#disableSelectInteraction();\n    }\n    if (this.#circleInteractionActive) {\n      this.#disableCircleInteraction();\n    }\n    // If there isn't an active draw interaction currently, we just return.\n    if (!this.#drawInteraction) return;\n    // Otherwise, we remove the interaction from the map.\n    this.#map.removeInteraction(this.#drawInteraction);\n    // Then we'll make sure to remove all event-listeners\n    this.#removeEventListeners();\n    // We're also making sure to set the private field to null\n    this.#drawInteraction = null;\n    // And remove the click-lock and the snap-helper\n    this.#map.clickLock.delete(\"coreDrawModel\");\n    this.#map.snapHelper.delete(\"coreDrawModel\");\n  };\n\n  // Creates an object that can be returned to the initiator of a\n  // set:er if the set:er fails due to a bad value provided.\n  #getSetFailedObject = (field, providedValue) => {\n    return {\n      status: \"FAILED\",\n      message: `Set:er failed. The set:er only accepts ${typeof field}, and was provided ${typeof providedValue}`,\n    };\n  };\n\n  // Removes the first feature that is present at the supplied\n  // pixel from the click-event.\n  #removeClickedFeature = (e) => {\n    // Get features present at the clicked feature.\n    const clickedFeatures = this.#map.getFeaturesAtPixel(e.pixel);\n    // We only care about features that have been drawn by a user.\n    const userDrawnFeatures = clickedFeatures.filter((f) =>\n      f.get(\"USER_DRAWN\")\n    );\n    // Let's make sure we found some feature(s) to remove. We're only removing\n    // the first one.\n    if (userDrawnFeatures.length > 0) {\n      // Let's get the first user-drawn feature\n      const feature = userDrawnFeatures[0];\n      // Then we remove it from the draw-source\n      this.removeFeature(feature);\n    }\n  };\n\n  // Publishes a modify-message with the clicked feature in the payload.\n  #editClickedFeature = (e) => {\n    // Get features present at the clicked feature.\n    const clickedFeatures = this.#map.getFeaturesAtPixel(e.pixel);\n    // We only care about features that have been drawn by a user.\n    const userDrawnFeatures = clickedFeatures.filter((f) =>\n      f.get(\"USER_DRAWN\")\n    );\n    // Let's get the (potential) first user-drawn feature, otherwise null.\n    const feature = userDrawnFeatures.length > 0 ? userDrawnFeatures[0] : null;\n    // Then we'll update the private field holding the feature currently chosen for editing.\n    this.#updateChosenEditFeature(feature);\n    // Then we'll publish a modify-message with the clicked feature in the payload (or null).\n    this.#publishInformation({\n      subject: \"drawModel.modify.mapClick\",\n      payLoad: feature,\n    });\n  };\n\n  // Updates the private field holding the feature which is currently chosen\n  // for edit. Also makes sure to set the \"EDIT_ACTIVE\" prop to false on the\n  // feature that is no longer chosen, and to true on the chosen feature.\n  // The \"EDIT_ACTIVE\" prop is used to style the chosen feature.\n  #updateChosenEditFeature = (feature) => {\n    this.#featureChosenForEdit &&\n      this.#featureChosenForEdit.set(\"EDIT_ACTIVE\", false);\n    // If we have a new feature clicked, and if the feature is not already\n    // marked as \"EDIT_ACTIVE\" (selected for edit), we set \"EDIT_ACTIVE\" to true.\n    feature && !feature.get(\"EDIT_ACTIVE\") && feature.set(\"EDIT_ACTIVE\", true);\n    // Let's update the chosen feature with whatever was clicked (might be null).\n    this.#featureChosenForEdit = feature;\n  };\n\n  // Refreshes the snap-helper by removing it and then adding it again.\n  #refreshSnapHelper = () => {\n    this.#map.snapHelper.delete(\"coreDrawModel\");\n    this.#map.snapHelper.add(\"coreDrawModel\");\n  };\n\n  // Enables a remove-interaction which allows the user to remove drawn features by clicking on them.\n  // We're also making sure to enable the click-lock so that the feature-info does not infer.\n  #enableRemoveInteraction = () => {\n    // We have to make sure to set a field so that the handlers responsible for deleting\n    // all active interactions knows that there is a remove-interaction to delete.\n    this.#removeInteractionActive = true;\n    // Let's add the clickLock to avoid the featureInfo etc.\n    this.#map.clickLock.add(\"coreDrawModel\");\n    // Then we'll add the event-handler responsible for removing clicked features.\n    this.#map.on(\"singleclick\", this.#removeClickedFeature);\n  };\n\n  // Disables the remove-interaction by removing the event-listener and disabling\n  // the click-lock.\n  #disableRemoveInteraction = () => {\n    this.#map.clickLock.delete(\"coreDrawModel\");\n    this.#map.un(\"singleclick\", this.#removeClickedFeature);\n    this.#removeInteractionActive = false;\n  };\n\n  // Enables an edit-interaction which allows the user to edit the shape of user-drawn\n  // features. The draw-model also makes sure to enable an on-click handler that publish\n  // an event when a feature is clicked (i.e. chosen for editing).\n  #enableEditInteraction = (settings) => {\n    // Let's set a field so that we know that edit is enabled.\n    this.#editInteractionActive = true;\n    // We're gonna need a handler that can update the feature-style when\n    // the modification is completed.\n    this.#map.on(\"singleclick\", this.#editClickedFeature);\n    // We also need a listener which listens for property-changes on the features.\n    // (We use a property on the feature to show that it is currently being edited).\n    this.#bindFeaturePropertyListener();\n    // Let's add the clickLock to avoid the featureInfo etc.\n    this.#map.clickLock.add(\"coreDrawModel\");\n    // Usually, the modify interaction is enabled at the same time as the edit-interaction,\n    // allowing the user to change the feature geometry.\n    // The user might pass \"modifyEnabled: false\" in the toggle-draw-settings, and in that case\n    // we do not enable the modify-interaction. Otherwise we check the \"keepModifyActive\" field,\n    // which keeps track of if the user had modify enabled the last time they enabled the edit-interaction.\n    (settings.modifyEnabled ?? this.#keepModifyActive) &&\n      this.#enableModifyInteraction();\n  };\n\n  // Disables the edit-interaction by removing the event-listener and disabling\n  // the click-lock.\n  #disableEditInteraction = () => {\n    // Remove the click-lock so that the feature-info works again,\n    this.#map.clickLock.delete(\"coreDrawModel\");\n    // Remove the event-listener\n    this.#map.un(\"singleclick\", this.#editClickedFeature);\n    // We also have to make sure to de-select the eventual features which might be selected for editing.\n    this.#removeFeatureEditSelection();\n    // Remove the feature-property-change-listener\n    this.#unBindFeaturePropertyListener();\n    // Disable the potential modify-interaction (it should only be active when the edit-interaction\n    // is active).\n    this.#disableModifyInteraction();\n    // Finally, we reset the field so we know that the interaction is no longer active.\n    this.#editInteractionActive = false;\n  };\n\n  #enableModifyInteraction = () => {\n    // If the edit-interaction is not active, we shouldn't enable the modify-interaction.\n    // The modify-interaction is an interaction that should be used on-top of the edit-interaction.\n    if (!this.#editInteractionActive) {\n      return {\n        status: \"FAILED\",\n        message:\n          \"Modify-interaction could not be enabled. Edit has to be enabled before enabling.\",\n      };\n    }\n    // Let's disable potential interaction that might be enabled already\n    this.#disableModifyInteraction();\n    // We have to make sure to set a field so that the handlers responsible for deleting\n    // all active interactions knows that there is an edit-interaction to delete.\n    this.#modifyInteraction = new Modify({ source: this.#drawSource });\n    // We're gonna need a handler that can update the feature-style when\n    // the modification is completed.\n    this.#modifyInteraction.on(\"modifyend\", this.#handleModifyEnd);\n    // Then we'll add the interaction to the map.\n    this.#map.addInteraction(this.#modifyInteraction);\n    // Let's add the clickLock to avoid the featureInfo etc...\n    this.#map.clickLock.add(\"coreDrawModel\");\n    //  ...and snap-helper for the snap-functionality.\n    this.#map.snapHelper.add(\"coreDrawModel\");\n    // Finally we return something so that the enabler knows that we've enabled.\n    return {\n      status: \"SUCCESS\",\n      message: \"Modify-interaction enabled.\",\n    };\n  };\n\n  // Disables and removes the Modify-interaction if there is one active currently.\n  #disableModifyInteraction = () => {\n    // If the modify-interaction is not active, we can abort.\n    if (!this.#modifyInteraction) {\n      return;\n    }\n    // Otherwise, let's disable it. First remove the interaction.\n    this.#map.removeInteraction(this.#modifyInteraction);\n    // Then we'll remove the event-listener\n    this.#modifyInteraction.un(\"modifyend\", this.#handleModifyEnd);\n    // And remove the snap-helper.\n    this.#map.snapHelper.delete(\"coreDrawModel\");\n    // Then we'll reset the field referring to the interaction\n    this.#modifyInteraction = null;\n  };\n\n  // Enables the Move-interaction (An interaction allowing the user to move features by selecting\n  // amount of meters and degrees the selected features should be moved). It is also possible to\n  // add a Translate-interaction on top, allowing the user to move features in the map by dragging them.\n  // The Translate-interaction is added by default if the draw-model is initiated with keepTranslateActive: true,\n  // and can be added afterwards calling setTranslateActive or by providing translateEnabled: true when enabling the\n  // Move-interaction.\n  #enableMoveInteraction = (settings) => {\n    // The Move-interaction will obviously need a Select-interaction so that the features to\n    // move can be selected.\n    this.#selectInteraction = new Select({ layers: [this.#drawLayer] });\n    // We need a handler catching the \"select\"-events so that we can keep track of if any\n    // features has been selected or not.\n    this.#selectInteraction.on(\"select\", this.#handleFeatureSelect);\n    // Then we'll add the interaction to the map...\n    this.#map.addInteraction(this.#selectInteraction);\n    // When this is done, we can set the private field keeping track of\n    // if the Move-interaction is active or not.\n    this.#moveInteractionActive = true;\n    // If we should enable the Translate-interaction, we do that as well.\n    (settings.translateEnabled ?? this.#keepTranslateActive) &&\n      this.#enableTranslateInteraction();\n    // ...finally we'll add the snap- and clickLock-helpers.\n    this.#map.clickLock.add(\"coreDrawModel\");\n    this.#map.snapHelper.add(\"coreDrawModel\");\n  };\n\n  // Enables a Translate-interaction, allowing users to move features by dragging them\n  // in the map.\n  #enableTranslateInteraction = () => {\n    // If the base Move-interaction is not active, the Translate-interaction cannot be enabled.\n    if (!this.#moveInteractionActive) {\n      return {\n        status: \"FAILED\",\n        message:\n          \"Translate-interaction could not be enabled. Move has to be enabled before enabling.\",\n      };\n    }\n    // Otherwise, we can create a new Translate-interaction...\n    this.#translateInteraction = new Translate({\n      features: this.#selectInteraction.getFeatures(),\n    });\n    // ...and add it to the map!\n    this.#map.addInteraction(this.#translateInteraction);\n    // We also have to make sure to refresh the snap-helper, otherwise\n    // the snap won't work on the translate-features.\n    this.#refreshSnapHelper();\n  };\n\n  // Disabled the Move-interaction and removed it from the map.\n  #disableMoveInteraction = () => {\n    // First, we'll remove the Move-interaction from the map\n    this.#map.removeInteraction(this.#selectInteraction);\n    // Then we'll remove the \"select\"-event-listener\n    this.#selectInteraction.un(\"select\", this.#handleFeatureSelect);\n    // Then we'll remove (potentially, there might not be any) the Translate-interaction.\n    this.#disableTranslateInteraction();\n    // Let's update the private fields so that we know that the Select- and Move-interactions\n    // are disabled.\n    this.#selectInteraction = null;\n    this.#moveInteractionActive = false;\n    // And remove the clickLock- and snap-helpers.\n    this.#map.clickLock.delete(\"coreDrawModel\");\n    this.#map.snapHelper.delete(\"coreDrawModel\");\n    // We also have to make sure to refresh all the feature-styles so that\n    // they are up-to-date with any potential moves.\n    this.refreshDrawLayer();\n  };\n\n  // Disabled the Translate-interaction if there is one active.\n  #disableTranslateInteraction = () => {\n    if (this.#translateInteraction) {\n      this.#map.removeInteraction(this.#translateInteraction);\n      this.#translateInteraction = null;\n    }\n  };\n\n  // Enables possibility to draw a circle with fixed radius by 'single-click'\n  #enableCircleInteraction = () => {\n    this.#map.clickLock.add(\"coreDrawModel\");\n    this.#circleInteractionActive = true;\n    this.#map.on(\"singleclick\", this.#createRadiusOnClick);\n  };\n\n  // Disables possibility to draw a circle with fixed radius by 'single-click'\n  #disableCircleInteraction = () => {\n    this.#map.clickLock.delete(\"coreDrawModel\");\n    this.#map.un(\"singleclick\", this.#createRadiusOnClick);\n    this.#circleInteractionActive = false;\n  };\n\n  // Enables functionality so that the user can select features from the map and\n  // create a \"copy\" of that feature.\n  #enableSelectInteraction = () => {\n    this.#map.clickLock.add(\"coreDrawModel\");\n    this.#map.on(\"singleclick\", this.#handleOnSelectClick);\n    this.#selectInteractionActive = true;\n  };\n\n  #disableSelectInteraction = () => {\n    this.#map.clickLock.delete(\"coreDrawModel\");\n    this.#map.un(\"singleclick\", this.#handleOnSelectClick);\n    this.#selectInteractionActive = true;\n  };\n\n  drawSelectedFeature = (feature) => {\n    try {\n      // We create a new feature with the same geometry as the supplied one. This way\n      // we ensure that the copy and the original feature are not connected.\n      const featureCopy = new Feature({\n        geometry: feature.getGeometry().clone(),\n      });\n      // We're gonna need to set some properties on the new feature... First, we'll set an ID.\n      featureCopy.setId(Math.random().toString(36).substring(2, 15));\n      // Then we'll set some draw-properties from the original feature.\n      featureCopy.set(\"USER_DRAWN\", true);\n      featureCopy.set(\"DRAW_METHOD\", feature.get(\"DRAW_METHOD\"));\n      featureCopy.set(\"TEXT_SETTINGS\", feature.get(\"TEXT_SETTINGS\"));\n      // We're gonna need to set some styling on the feature as-well. Let's use the same\n      // styling as on the supplied feature.\n      featureCopy.setStyle(this.#getFeatureStyle(featureCopy));\n      // Then we can add the feature to the draw-layer!\n      this.#drawSource.addFeature(featureCopy);\n    } catch (error) {\n      console.error(`Failed to add selected feature. Error: ${error}`);\n    }\n  };\n\n  #handleOnSelectClick = async (event) => {\n    try {\n      // Try to fetch features from WMS-layers etc. (Also from all vector-layers).\n      const clickResult = await new Promise((resolve) =>\n        handleClick(event, event.map, resolve)\n      );\n      // The response should contain an array of features\n      const { features } = clickResult;\n      // Which might contain features without geometry. We have to make sure we remove those.\n      const featuresWithGeom = features.filter((feature) =>\n        feature.getGeometry()\n      );\n      // If we've fetched exactly one feature, we can add it straight away...\n      featuresWithGeom.length === 1 &&\n        this.drawSelectedFeature(featuresWithGeom[0]);\n      // If we have more than one feature, we'll have to let the user\n      // pick which features they want to add. Let's publish an event that the view can catch...\n      if (featuresWithGeom.length > 1) {\n        return this.#publishInformation({\n          subject: \"drawModel.select.click\",\n          payLoad: featuresWithGeom,\n        });\n      }\n    } catch (error) {\n      console.error(\n        `Failed to select features in drawModel... Error: ${error}`\n      );\n    }\n  };\n\n  // Creates a Feature with a circle geometry with fixed radius\n  // (If the radius is bigger than 0).\n  #createRadiusOnClick = (e) => {\n    // If the radius is zero we don't want to add a circle...\n    if (this.#circleRadius === 0) {\n      return;\n    }\n    // Create the feature\n    const feature = new Feature({\n      geometry: new CircleGeometry(e.coordinate, this.#circleRadius),\n    });\n    // Add the feature to the draw-source\n    this.#drawSource.addFeature(feature);\n    // Make sure to trigger the draw-end event so that all props etc. are\n    // set on the feature.\n    this.#handleDrawEnd({ feature });\n  };\n\n  // Handles the \"select\"-event that fires from the event-listener added when adding\n  // the Move-interaction.\n  #handleFeatureSelect = (e) => {\n    // Let's just publish the currently selected features on the observer so that\n    // the views can keep track of them if they want to.\n    this.#publishInformation({\n      subject: \"drawModel.move.select\",\n      payLoad: e.selected,\n    });\n    // We also has to refresh the draw-layer to make sure all the styling is updated.\n    // For example: If an arrow is moved, we have to refresh the style so that the arrow\n    // head is in the correct location.\n    e.deselected.forEach((f) => {\n      f.setStyle(this.#getFeatureStyle(f));\n    });\n  };\n\n  // Binds a listener to each feature which fires on property-change\n  #bindFeaturePropertyListener = () => {\n    this.#drawSource.forEachFeature((f) => {\n      f.on(\"propertychange\", this.#handleFeaturePropertyChange);\n    });\n  };\n\n  // Un-binds the property-change-listeners\n  #unBindFeaturePropertyListener = () => {\n    this.#drawSource.forEachFeature((f) => {\n      f.un(\"propertychange\", this.#handleFeaturePropertyChange);\n    });\n  };\n\n  // Handler targeted when any feature property has changed. If any property change, we have\n  // to make sure to refresh the draw-layer (since some properties affect the feature-styling!)\n  #handleFeaturePropertyChange = (e) => {\n    return this.refreshDrawLayer();\n  };\n\n  // Sets the \"EDIT_ACTIVE\" prop to false on all features in the draw-source.\n  // Used when disabling the edit-interaction, since we don't want any features\n  // selected for editing after the edit-interaction is removed.\n  #removeFeatureEditSelection = () => {\n    this.#drawSource.forEachFeature((f) => {\n      if (f.get(\"EDIT_ACTIVE\")) {\n        f.set(\"EDIT_ACTIVE\", false);\n      }\n    });\n  };\n\n  // Toggles the draw-interaction on and off if it is currently on.\n  // This refresh makes sure new settings are applied.\n  #refreshDrawInteraction = () => {\n    if (this.#drawInteraction) {\n      this.toggleDrawInteraction(this.#drawInteraction.get(\"DRAW_METHOD\"));\n    }\n  };\n\n  // Returns a valid draw-interaction-type from the supplied\n  // draw-method. For example, if the user wants to create a rectangle,\n  // the draw-interaction-type should apparently be \"Circle\".\n  #getDrawInteractionType = (method) => {\n    switch (method) {\n      case \"Arrow\":\n        return \"LineString\";\n      case \"Rectangle\":\n        return \"Circle\";\n      case \"Text\":\n        return \"Point\";\n      default:\n        return method;\n    }\n  };\n\n  // Returns wether we should be free-hand-drawing or not.\n  // Circles and Rectangles are always drawn with free-hand set to true.\n  #isFreeHandDrawing = (drawMethod, settings) => {\n    return [\"Circle\", \"Rectangle\"].includes(drawMethod)\n      ? true\n      : settings.freehand ?? false;\n  };\n\n  // Accepts a feature with \"CIRCLE_RADIUS\" and \"CIRCLE_CENTER\" properties.\n  // Updates the feature-geometry to a Circle-geometry with the supplied center and radius.\n  #createRealCircleGeometry = (feature) => {\n    try {\n      const center = JSON.parse(feature.get(\"CIRCLE_CENTER\"));\n      const radius = parseFloat(feature.get(\"CIRCLE_RADIUS\"));\n      feature.setGeometry(new CircleGeometry(center, radius));\n    } catch (error) {\n      console.error(\n        `Failed to create 'real' Circle geometry from supplied feature, error: ${error}`\n      );\n    }\n  };\n\n  // Creates an OpenLayers Circle geometry from a simplified circle geometry (polygon).\n  // Since the calculation from the extent does not seem to result in the exact radius,\n  // we allow for a optional radius to be passed.\n  #creteCircleGeomFromSimplified = (simplified, opt_radius) => {\n    // First we'll have to get the extent of the simplified circle\n    const simplifiedExtent = simplified.getExtent();\n    // Then we'll calculate the center and radius\n    const center = getCenter(simplifiedExtent);\n    const radius = opt_radius ?? getWidth(simplifiedExtent) / 2;\n    // Finally we'll return a circle geometry based on those:\n    return new CircleGeometry(center, radius);\n  };\n\n  // Removes the property-change-listeners from all features and then adds\n  // them again. Useful if a new feature is added to the draw-source, and you\n  // have to make sure the new feature has a listener.\n  reBindFeaturePropertyListener = () => {\n    this.#unBindFeaturePropertyListener();\n    this.#bindFeaturePropertyListener();\n  };\n\n  // Refreshes the text-style on the features in the draw-source. Useful for when a feature-prop\n  // has been changed and the text-style has to be updated.\n  refreshFeaturesTextStyle = () => {\n    this.#refreshFeaturesTextStyle();\n  };\n\n  // CUSTOM ADDER: Adds the supplied feature to the draw-source\n  // On top of just adding the feature to the draw-source, it makes sure\n  // to create some proper styling and emit events on the observer.\n  // If you want to use the adder without emitting events, you can pass\n  // silent: true in the settings.\n  addFeature = (feature, settings) => {\n    // The initiator might have supplied some settings, for example \"silent\",\n    // which states if we should avoid firing events when adding the feature.\n    // If the silent-property is not supplied, we will fire events.\n    const silent = settings?.silent ?? false;\n    try {\n      // The supplied feature might contain a property with information regarding\n      // circle-radius. If that is the case, we have to replace the Point-geometry\n      // with a Circle-geometry with the supplied radius. This case appears when circles\n      // has been saved in LS, since geoJSON does not support Circles.\n      feature.get(\"CIRCLE_RADIUS\") && this.#createRealCircleGeometry(feature);\n      // The supplied feature might contain a property with style-information\n      // that has been set in an earlier session. Let's apply that style (if present)\n      // before we add the feature to the source.\n      const extractedStyle = feature.get(\"EXTRACTED_STYLE\");\n      extractedStyle &&\n        feature.setStyle(this.#getFeatureStyle(feature, extractedStyle));\n      // When we're done styling we can add the feature.\n      this.#drawSource.addFeature(feature);\n      // Then we'll publish some information about the addition. (If we're not supposed to be silent).\n      !silent &&\n        this.#publishInformation({\n          subject: \"drawModel.featureAdded\",\n          payLoad: feature,\n        });\n    } catch (error) {\n      console.error(`Error while adding feature: ${error}`);\n      this.#publishInformation({\n        subject: \"drawModel.addFeature.error\",\n        payLoad: error,\n      });\n    }\n  };\n\n  // Method used when adding features that has been parsed using the kmlModel-parser.\n  // The method makes sure to extract and parse eventual style- and text-settings that\n  // has been stored in the kml-features.\n  addKmlFeatures = (features) => {\n    // Let's check what the current draw-interaction is. If we have a draw-interaction\n    // active, we have to make sure to disable it so that any active event-listeners doesn't\n    // fire when adding the kml-features.\n    const currentInteraction = this.#drawInteraction\n      ? this.#drawInteraction.get(\"DRAW_METHOD\")\n      : null;\n    // If the interaction isn't null, let's toggle the current interaction off.\n    currentInteraction && this.toggleDrawInteraction(\"\");\n    features.forEach((f) => {\n      // If a draw-method-property is missing from the imported features, we have to add it.\n      // Why? Well, in the sketch-tool (which is using the draw-model) we rely on the fact that\n      // the draw-method is set so that we can present proper styling menus (polygons and lines have\n      // different menus for example). The imported kml-features might not have been created with\n      // the hajk-drawModel, and therefore lacks this property. We'll set it to the geometry-type\n      // which should be sufficient.\n      !f.get(\"DRAW_METHOD\") &&\n        f.set(\n          \"DRAW_METHOD\",\n          f.get(\"geometryType\") || f.getGeometry().getType()\n        );\n      // Let's grab the style- and text-settings. (At this point they will\n      // can be undefined, a string, or the actual objects). We also have to grab the userDrawn-prop\n      // (which should be a boolean, but since we're dealing with kml, it might be a string...).\n      const extractedStyle = f.get(\"EXTRACTED_STYLE\");\n      const textSettings = f.get(\"TEXT_SETTINGS\");\n      const userDrawn = f.get(\"USER_DRAWN\");\n      // If the setting exist, and they are strings, we parse them and apply the parsed setting.\n      typeof extractedStyle === \"string\" &&\n        f.set(\"EXTRACTED_STYLE\", JSON.parse(extractedStyle));\n      typeof textSettings === \"string\" &&\n        f.set(\"TEXT_SETTINGS\", JSON.parse(textSettings));\n      typeof userDrawn === \"string\" &&\n        f.set(\"USER_DRAWN\", JSON.parse(userDrawn));\n      // Then we can add the feature to the map. We'll provide \"silent\" as well,\n      // since we don't want any events to trigger when adding kml-features. (For example\n      // when adding a text-feature, normally an event would fire, allowing the user to enter\n      // the text they want. Now we do not want that behavior).\n      this.addFeature(f, { silent: true });\n    });\n    // Let's make sure to refresh all features text-style to make sure they are up-to-date\n    this.#refreshFeaturesTextStyle();\n    // If we had a draw-interaction active before the kml-import, we have to enable it again.\n    currentInteraction && this.toggleDrawInteraction(currentInteraction);\n  };\n\n  // Toggles the hidden-property of all features connected to a kml-import\n  // with the supplied id.\n  toggleKmlFeaturesVisibility = (id) => {\n    this.#drawSource.getFeatures().forEach((f) => {\n      if (f.get(\"KML_ID\") === id) {\n        const featureHidden = f.get(\"HIDDEN\") ?? false;\n        f.set(\"HIDDEN\", !featureHidden);\n        f.setStyle(this.#getFeatureStyle(f));\n      }\n    });\n  };\n\n  // Toggles the show-text-property of all features connected to a kml-import\n  // with the supplied id.\n  toggleKmlFeaturesTextVisibility = (id) => {\n    this.#drawSource.getFeatures().forEach((f) => {\n      if (f.get(\"KML_ID\") === id) {\n        const featureTextShown = f.get(\"SHOW_TEXT\") ?? true;\n        f.set(\"SHOW_TEXT\", !featureTextShown);\n        f.setStyle(this.#getFeatureStyle(f));\n      }\n    });\n  };\n\n  // Removes all features with the supplied kml-id.\n  removeKmlFeaturesById = (id) => {\n    this.#drawSource.getFeatures().forEach((f) => {\n      if (f.get(\"KML_ID\") === id) {\n        this.#drawSource.removeFeature(f);\n      }\n    });\n  };\n\n  // Clones the supplied ol-feature and adds it to the map (the added clone\n  // will be offset just a tad to the east of the supplied feature).\n  duplicateFeature = (feature) => {\n    try {\n      // First we'll have to get a clone of the supplied feature\n      const duplicate = this.#createDuplicateFeature(feature);\n      // Then we'll have to check if we're dealing with a circle-geometry.\n      const isCircle = duplicate.getGeometry() instanceof CircleGeometry;\n      // We also have to make sure to store the eventual radius so that we can use\n      // that to create a 'real' circle later.\n      const radius = isCircle ? duplicate.getGeometry().getRadius() : 0;\n      // If we are dealing with a circle, we have to create a simplified geometry (since\n      // geoJSON does not like OpenLayers circles). Let's update the geometry if we are:\n      if (isCircle) {\n        duplicate.setGeometry(fromCircle(duplicate.getGeometry()));\n      }\n      // Then we'll have to create a GeoJSON-feature from the ol-feature (since turf only accepts geoJSON).\n      const gjFeature = this.#geoJSONParser.writeFeatureObject(duplicate);\n      // We want to add the cloned feature with an offset to the east. First, we'll\n      // have to get the offset-amount.\n      const offset = this.#getDuplicateOffsetAmount();\n      // Then we'll translate (move) the geoJSON-feature slightly to the east.\n      const translated = transformTranslate(gjFeature, offset, 140);\n      // Then we have to read the geometry from the translated geoJSON\n      const translatedGeom = this.#geoJSONParser.readGeometry(\n        translated.geometry\n      );\n      // When thats done, we'll update the duplicates geometry. If we are dealing\n      // with a circle, we have to create a \"real\" circle:\n      if (isCircle) {\n        duplicate.setGeometry(\n          this.#creteCircleGeomFromSimplified(translatedGeom, radius)\n        );\n      } else {\n        // Otherwise we can just set the geometry.\n        duplicate.setGeometry(translatedGeom);\n      }\n      // Since the feature we are duplicating is probably selected for edit, we have to\n      // make sure to toggle the edit-flag on the new feature to false.\n      duplicate.set(\"EDIT_ACTIVE\", false);\n      // Then we'll add the cloned feature to the map!\n      this.addFeature(duplicate);\n      // Finally, we'll refresh the draw-layer so that the feature styles are\n      // up to date.\n      this.refreshDrawLayer();\n    } catch (error) {\n      console.error(\n        `Could not duplicate the supplied feature. Error: ${error}`\n      );\n    }\n  };\n\n  // Moves the features currently selected via the Move-interaction.\n  // The features are moved the supplied length (in meters) in the supplied\n  // direction (in degrees, where north is 0 and east is 90 and so on).\n  translateSelectedFeatures = (length, angle) => {\n    this.#selectInteraction.getFeatures().forEach((f) => {\n      try {\n        // Since geoJSON cannot handle OL's circle-geometries, we'll have to check\n        // if we're dealing with a circle before creating the geoJSON-feature...\n        const isCircle = f.getGeometry() instanceof CircleGeometry;\n        // We also have to make sure to store the eventual radius so that we can use that to create a 'real' circle later.\n        const radius = isCircle ? f.getGeometry().getRadius() : 0;\n        // If we are dealing with a circle, we have to set the feature-geometry to a\n        // simplified circle (Don't worry, we'll create a \"real\" circle again later).\n        if (isCircle) {\n          f.setGeometry(fromCircle(f.getGeometry()));\n        }\n        // Then we'll create a GeoJSON-feature from the ol-feature (since turf only accepts geoJSON).\n        const gjFeature = this.#geoJSONParser.writeFeatureObject(f);\n        // Then we'll translate the feature according to the supplied parameters\n        const translated = transformTranslate(gjFeature, length / 1000, angle);\n        // When thats done, we'll read the geometry from the translated geoJSON\n        const translatedGeometry = this.#geoJSONParser.readGeometry(\n          translated.geometry\n        );\n        // When thats done, we'll update the feature geometry to the translated one. If we are dealing\n        // with a circle, we have to create a \"real\" circle:\n        if (isCircle) {\n          f.setGeometry(\n            this.#creteCircleGeomFromSimplified(translatedGeometry, radius)\n          );\n        } else {\n          // Otherwise we can just set the geometry.\n          f.setGeometry(translatedGeometry);\n        }\n      } catch (error) {\n        console.error(`Failed to translate selected features. Error: ${error}`);\n      }\n    });\n  };\n\n  // Returns a clone of the supplied feature. Makes sure to clone both\n  // the feature and its style.\n  #createDuplicateFeature = (feature) => {\n    // First we'll clone the supplied feature.\n    const duplicate = feature.clone();\n    // Then we'll have to clone the style (so that the feature-styles are not connected).\n    // We only want the first style-object from the style array (since the rest are highlight-styles).\n    // The above applied to all features except for Arrows, which aren't highlighted.\n    const style =\n      feature.get(\"DRAW_METHOD\") === \"Arrow\"\n        ? feature.getStyle().map((style) => style.clone())\n        : Array.isArray(feature.getStyle())\n        ? feature.getStyle()[0].clone()\n        : feature.getStyle().clone();\n    // Then we'll apply the cloned-style.\n    duplicate.setStyle(style);\n    // Finally we'll return the cloned feature.\n    return duplicate;\n  };\n\n  // Cloned features are going to be placed offset from the original feature when\n  // added to the map. This function returns an offset-amount that depends on the current\n  // zoom-level. This is done by calculating the area of the current map-extent, and then\n  // take a fraction of that number. (The returned number is the offset from the feature in\n  // kilometers).\n  #getDuplicateOffsetAmount = () => {\n    // First we'll get the current map-extent.\n    const mapExtent = this.#map.getView().calculateExtent(this.#map.getSize());\n    // Then we'll:\n    // 1: Get the extent-area\n    // 2: Take the square-root of the area (to get approximately the length of one map-side).\n    // 3: Take a fraction of one side of the map, and return that as the offset-amount.\n    return Math.sqrt(getExtentArea(mapExtent)) * 0.00005;\n  };\n\n  // CUSTOM REMOVER: Removes the supplied feature from the draw-source\n  // Also makes sure to emit an event on the observer.\n  removeFeature = (feature) => {\n    // Let's start by removing the supplied feature from the draw-source\n    // We won't remove if it set as hidden currently (otherwise we might confuse the users\n    // by removing stuff they're not seeing at the time of removal).\n    if (feature.get(\"HIDDEN\") !== true) {\n      this.#drawSource.removeFeature(feature);\n      // Then we (potentially) publish that we've removed a feature.\n      this.#publishInformation({\n        subject: \"drawModel.featureRemoved\",\n        payLoad: feature,\n      });\n    }\n  };\n\n  // Accepts an RGBA-object containing r-, g-, b-, and a-properties, or an array\n  // with four elements (r, g, b, and a in that order)...\n  // Returns the string representation of the supplied object (or array).\n  getRGBAString = (o) => {\n    // If nothing was supplied, return an empty string\n    if (!o) {\n      return null;\n    }\n    // Otherwise we check the type and return an rgba-string.\n    return Array.isArray(o)\n      ? `rgba(${o[0]},${o[1]},${o[2]},${o[3]})`\n      : typeof o === \"object\"\n      ? `rgba(${o.r},${o.g},${o.b},${o.a})`\n      : o;\n  };\n\n  // Accepts a color-string (hex or rgba) and returns an object containing r-, g-, b-, and a-properties.\n  parseColorString = (s) => {\n    try {\n      // First, we make sure we're dealing with a string with proper length. If not, return an empty object.\n      if (typeof s !== \"string\" || s.length < 7) {\n        return {};\n      }\n      // Then we'll check if the supplied string is an hex-string (must start with hash and be 7 chars).\n      // Cannot handle hex-shorthands such as #fff obviously.\n      if (s.length === 7 && s.startsWith(\"#\")) {\n        // If it is, we parse the hex-string and return an object containing the\n        // corresponding values.\n        const [r, g, b] = s.match(/\\w\\w/g).map((c) => parseInt(c, 16));\n        return { r, g, b, a: 1 };\n      }\n      // Otherwise, some regex-magic.\n      // 1. RegEx that matches stuff between a set of parentheses\n      // 2. Execute that regex on the input string, but first remove any whitespace it may contain\n      // 3. RegEx exec returns an array. Grab the second element, which will contain the value.\n      // 4. Split the value to extract individual rgba values\n      const o = /\\(([^)]+)\\)/.exec(s.replace(/\\s/g, \"\"))[1].split(\",\");\n      return {\n        r: parseFloat(o[0]),\n        g: parseFloat(o[1]),\n        b: parseFloat(o[2]),\n        a: parseFloat(o[3]),\n      };\n    } catch (error) {\n      console.error(`Color-string parsing failed: ${error}`);\n      return null;\n    }\n  };\n\n  // Toggles the current draw interaction. To enable the draw interaction,\n  // pass one of the allowed draw-interactions: \"Polygon\", \"Rectangle\", \"Circle\", or \"Delete\"\n  // as the first parameter. To disable the draw-interaction, pass nothing, or an empty string.\n  toggleDrawInteraction = (drawMethod = \"\", settings = {}) => {\n    // If this method is fired, the first thing we have to do is to remove the (potentially)\n    // already active interaction. (We never want two interactions active at the same time...)\n    this.#disablePotentialInteraction();\n    // Check if we are supposed to be toggling the draw interaction off. If we're toggling off,\n    // we make sure to abort so that we're not activating anything.\n    if (!drawMethod || drawMethod === \"\") {\n      return;\n    }\n    // Check if the supplied method is set to \"Delete\", \"Edit\", or \"Move\", if it is, we activate the remove, edit, or move\n    // interaction. Since these are special interactions, (not real ol-draw-interactions) we make sure not to continue executing.\n    if (drawMethod === \"Delete\") {\n      return this.#enableRemoveInteraction(settings);\n    }\n    if (drawMethod === \"Edit\") {\n      return this.#enableEditInteraction(settings);\n    }\n    if (drawMethod === \"Move\") {\n      return this.#enableMoveInteraction(settings);\n    }\n    if (drawMethod === \"Select\") {\n      return this.#enableSelectInteraction(settings);\n    }\n    if (drawMethod === \"Circle\") {\n      this.#enableCircleInteraction();\n    }\n    // If we've made it this far it's time to enable a new draw interaction!\n    // First we must make sure to gather some settings and defaults.\n    const type = this.#getDrawInteractionType(drawMethod);\n    // Are we going to be free-hand drawing?\n    const freehand = this.#isFreeHandDrawing(drawMethod, settings);\n    // Then we'll add the interaction!\n    this.#drawInteraction = new Draw({\n      source: this.#drawSource,\n      type: type,\n      freehand: freehand,\n      stopClick: true,\n      geometryFunction: drawMethod === \"Rectangle\" ? createBox() : null,\n      style: this.#getDrawStyle(),\n    });\n    // Let's set the supplied draw-method as a property on the draw-interaction\n    // so that we can keep track of if we're creating special features (arrows etc).\n    this.#drawInteraction.set(\"DRAW_METHOD\", drawMethod);\n    // Then we'll add all draw listeners\n    this.#addEventListeners(settings);\n    // Then we'll add the interaction to the map!\n    this.#map.addInteraction(this.#drawInteraction);\n    // Finally we'll add the clickLock to avoid the featureInfo etc...\n    this.#map.clickLock.add(\"coreDrawModel\");\n    //  ...and snap-helper for the snap-functionality.\n    this.#map.snapHelper.add(\"coreDrawModel\");\n  };\n\n  // Fits the map to the extent of the drawn features in the draw-source\n  zoomToCurrentExtent = () => {\n    // Let's make sure that the current extent is not null.\n    if (this.#currentExtent === null) {\n      return;\n    }\n    // If the extent is not null, we'll check that the current extent is finite\n    if (this.#currentExtent.map(Number.isFinite).includes(false) === false) {\n      // If it is, we can fit the map to that extent!\n      this.#fitMapToExtent(this.#currentExtent);\n    }\n  };\n\n  // We will need a way to remove all drawn features from the draw-source.\n  // Why aren't we using a simple \"clear()\" one might ask =>  simply because\n  // the draw-source might be connected to the search-source for example, and we\n  // don't want to remove all search features, only the user drawn ones.\n  removeDrawnFeatures = () => {\n    // Let's get all the features in the draw-source that have been drawn\n    const drawnFeatures = this.getAllDrawnFeatures();\n    // Since OL does not supply a \"removeFeatures\" method, we have to map\n    // over the array, and remove every single feature one by one... (Remember\n    // that currently hidden features should be ignored).\n    drawnFeatures\n      .filter((f) => f.get(\"HIDDEN\") !== true)\n      .forEach((feature) => {\n        this.#drawSource.removeFeature(feature);\n      });\n    // When the drawn features has been removed, we have to make sure\n    // to update the current extent.\n    this.#currentExtent = this.#drawSource.getExtent();\n    // Then we (potentially) publish that we've removed a bunch of features.\n    this.#publishInformation({\n      subject: \"drawModel.featuresRemoved\",\n      payLoad: drawnFeatures,\n    });\n    return { status: \"SUCCESS\", removedFeatures: drawnFeatures };\n  };\n\n  // Set:er allowing us to change which layer the draw-model will interact with\n  setLayer = (layerName) => {\n    // We're not allowing the layer to be changed while the draw interaction is active...\n    if (this.#drawInteraction !== null) {\n      console.warn(\n        \"The layer cannot be changed. The draw interaction is currently active. Disable the draw interaction before changing layer.\"\n      );\n      return { status: \"FAILED\", message: \"Disable draw to change layer.\" };\n    }\n    // First we must update the private field holding the current layer name\n    this.#layerName = layerName;\n    // Then we must initiate the draw-layer. This will either get the layer\n    // corresponding to the supplied name, or create a new one.\n    this.#initiateDrawLayer();\n    // When the current layer changes, the current extent will obviously\n    // change as well.\n    this.#currentExtent = this.#drawSource.getExtent();\n    return { status: \"SUCCESS\", message: `Layer changed to ${layerName}` };\n  };\n\n  // Set:er allowing us to change if a tooltip should be shown when drawing\n  setShowDrawTooltip = (drawTooltipActive) => {\n    // Let's make sure we're provided proper input before we set anything\n    if (typeof drawTooltipActive !== \"boolean\") {\n      // If we were not, let's return a fail message\n      return this.#getSetFailedObject(this.#showDrawTooltip, drawTooltipActive);\n    }\n    // If we've made it this far, we can go ahead and set the internal value.\n    this.#showDrawTooltip = drawTooltipActive;\n    // And return a success-message\n    return {\n      status: \"SUCCESS\",\n      message: `Draw tooltip is now ${drawTooltipActive ? \"shown\" : \"hidden\"}`,\n    };\n  };\n\n  // Set:er allowing us to change the style settings used in the draw-layer\n  // The fill- and strokeColor passed might be either a string, or an object containing\n  // r-, g-, b-, and a-properties. If they are objects, we have to make sure to parse them\n  // to strings before setting the new style-settings.\n  setDrawStyleSettings = (newStyleSettings) => {\n    // The fill- and strokeColor might have to be parsed to strings, let's\n    // destruct them and parse them if we have to.\n    const { fillColor, strokeColor } = newStyleSettings;\n    // Create a new object containing the potentially parsed objects.\n    const parsedStyle = {\n      // We still want to pass all the other settings...\n      ...newStyleSettings,\n      //... and the potentially parsed colors.\n      fillColor:\n        typeof fillColor !== \"string\"\n          ? this.getRGBAString(fillColor)\n          : fillColor,\n      strokeColor:\n        typeof strokeColor !== \"string\"\n          ? this.getRGBAString(strokeColor)\n          : strokeColor,\n    };\n    // Then we'll update the style.\n    this.#drawStyleSettings = parsedStyle;\n    // To make sure the new style is shown in the draw-interaction, we have\n    // to refresh the interaction if it is currently active.\n    this.#refreshDrawInteraction();\n  };\n\n  // Makes sure all features are re-drawn to make sure the latest style is applied.\n  // The arrows are handled separately since they need some special styling...\n  refreshDrawLayer = () => {\n    this.#drawSource.forEachFeature((f) => {\n      if (f.get(\"DRAW_METHOD\") === \"Arrow\") {\n        this.#refreshArrowStyle(f);\n      } else {\n        f.setStyle(this.#getFeatureStyle(f));\n      }\n    });\n  };\n\n  // Updates the supplied features' <attribute> with the supplied <value>.\n  // When the attribute has been updated, the style is refreshed.\n  setFeatureAttribute = (feature, attribute, value) => {\n    // If no feature was supplied, or if the supplied 'feature' is not\n    // a feature, we'll abort.\n    if (!(feature instanceof Feature)) {\n      return;\n    }\n    // Otherwise we'll update the attribute.\n    feature.set(attribute, value);\n  };\n\n  // Updates the Text-style-settings.\n  setTextStyleSettings = (newStyleSettings) => {\n    this.#textStyleSettings = newStyleSettings;\n  };\n\n  // Enabled the Modify-interaction\n  setModifyActive = (active) => {\n    this.#keepModifyActive = active;\n    active ? this.#enableModifyInteraction() : this.#disableModifyInteraction();\n  };\n\n  // Enabled the Translate-interaction\n  setTranslateActive = (active) => {\n    this.#keepTranslateActive = active;\n    active\n      ? this.#enableTranslateInteraction()\n      : this.#disableTranslateInteraction();\n  };\n\n  setMeasurementSettings = (settings) => {\n    // First we'll update the private field\n    this.#measurementSettings = settings;\n    // Then we have to refresh the style so that the change is shown.\n    this.#refreshFeaturesTextStyle();\n  };\n\n  setCircleRadius = (radius) => {\n    this.#circleRadius = parseInt(radius);\n    // Ensure is not NaN\n    if (Number.isNaN(this.#circleRadius)) {\n      this.#circleRadius = 0;\n    }\n  };\n\n  getMeasurementSettings = () => {\n    return this.#measurementSettings;\n  };\n\n  // Get:er returning the name of the draw-layer.\n  getCurrentLayerName = () => {\n    return this.#layerName;\n  };\n\n  // Get:er returning the currently connected Vector-source\n  getCurrentVectorSource = () => {\n    return this.#drawSource;\n  };\n\n  // Get:er returning the current extent of the draw-source.\n  getCurrentExtent = () => {\n    return this.#currentExtent;\n  };\n\n  // Get:er returning if the modify-interaction is active.\n  getModifyActive = () => {\n    return this.#modifyInteraction ? true : false;\n  };\n\n  // Get:er returning if the modify-interaction is active.\n  getTranslateActive = () => {\n    return this.#translateInteraction ? true : false;\n  };\n\n  // Get:er returning the state of the showDrawTooltip\n  getShowDrawTooltip = () => {\n    return this.#showDrawTooltip;\n  };\n\n  // Get:er returning the current draw-style settings\n  getDrawStyleSettings = () => {\n    return this.#drawStyleSettings;\n  };\n\n  // Get:er returning the current text-style settings\n  getTextStyleSettings = () => {\n    return this.#textStyleSettings;\n  };\n\n  // Get:er returning circle radius\n  getCircleRadius = () => {\n    return this.#circleRadius;\n  };\n}\nexport default DrawModel;\n"],"names":["DrawModel","settings","observerPrefix","subject","payLoad","prefixedSubject","publish","strokeColor","lineDash","strokeWidth","fillColor","showText","showArea","showPerimeter","areaUnit","lengthUnit","precision","foregroundColor","backgroundColor","size","Error","some","layer","getLayers","getArray","get","VectorLayer","connectedLayer","find","getSource","set","addLayer","document","createElement","setAttribute","Overlay","element","offset","positioning","addOverlay","parentNode","removeElement","feature","settingsOverride","getStyle","Style","currentStyle","baseLineStyle","Array","isArray","setImage","textStyle","setText","console","warn","featureDrawMethod","featureIsPoint","getGeometry","Point","featureIsTextType","Text","textAlign","textBaseline","font","fill","Fill","color","text","overflow","stroke","Stroke","width","offsetX","offsetY","rotation","scale","baseStyle","baseStroke","getStroke","setWidth","setLineDash","svgString","window","btoa","baseColor","getColor","styles","forEachSegment","start","end","dx","dy","Math","atan2","push","geometry","image","Icon","src","strokeStyle","anchor","rotateWithView","Circle","radius","coordinates","MultiPoint","error","getType","fromCircle","getCoordinates","labelType","reduce","acc","curr","type","round","value","measurement","prefix","showLength","formatted","featureTitle","measurementLabel","length","featureMeasure","Number","toFixed","toLocaleString","showAreaPrefix","CircleGeometry","getRadius","pow","PI","LineString","getLength","getArea","linearRingCoords","getLinearRing","dash","fillStyle","featureStyle","getFill","getRGBAString","message","s","getLineDash","getWidth","getImage","extractFeatureStyleInfo","imageStyle","getAllDrawnFeatures","filter","f","forEach","setStyle","VectorSource","wrapX","source","layerType","zIndex","caption","getFeatures","getView","fit","getSize","padding","maxZoom","un","removeEventListener","on","addEventListener","handleDrawStart","handleDrawEnd","handlePointerMove","handleAddFeature","e","features","innerHTML","setPosition","target","toolTipText","coordinate","keyCode","removeLastPoint","removeInteraction","clickLock","delete","snapHelper","field","providedValue","status","userDrawnFeatures","getFeaturesAtPixel","pixel","removeFeature","add","modifyEnabled","Modify","addInteraction","Select","layers","translateEnabled","Translate","refreshDrawLayer","drawSelectedFeature","featureCopy","Feature","clone","setId","random","toString","substring","addFeature","event","Promise","resolve","handleClick","map","clickResult","featuresWithGeom","selected","deselected","forEachFeature","toggleDrawInteraction","method","drawMethod","includes","freehand","center","JSON","parse","parseFloat","setGeometry","simplified","opt_radius","simplifiedExtent","getExtent","getCenter","reBindFeaturePropertyListener","refreshFeaturesTextStyle","silent","extractedStyle","addKmlFeatures","currentInteraction","textSettings","userDrawn","toggleKmlFeaturesVisibility","id","featureHidden","toggleKmlFeaturesTextVisibility","featureTextShown","removeKmlFeaturesById","duplicateFeature","duplicate","isCircle","gjFeature","writeFeatureObject","translated","transformTranslate","translatedGeom","readGeometry","translateSelectedFeatures","angle","translatedGeometry","style","mapExtent","calculateExtent","sqrt","getExtentArea","o","r","g","b","a","parseColorString","startsWith","match","c","parseInt","exec","replace","split","Draw","stopClick","geometryFunction","createBox","zoomToCurrentExtent","isFinite","removeDrawnFeatures","drawnFeatures","removedFeatures","setLayer","layerName","setShowDrawTooltip","drawTooltipActive","setDrawStyleSettings","newStyleSettings","parsedStyle","setFeatureAttribute","attribute","setTextStyleSettings","setModifyActive","active","setTranslateActive","setMeasurementSettings","setCircleRadius","isNaN","getMeasurementSettings","getCurrentLayerName","getCurrentVectorSource","getCurrentExtent","getModifyActive","getTranslateActive","getShowDrawTooltip","getDrawStyleSettings","getTextStyleSettings","getCircleRadius","this","GeoJSON","featureProjection","getProjection","observer","measurementSettings","drawStyleSettings","textStyleSettings","modifyDefaultEnabled","translateDefaultEnabled","showDrawTooltip"],"sourceRoot":""}